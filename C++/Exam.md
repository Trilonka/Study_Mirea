# Шаблоны С++

**Шаблоны позволяют достичь одну из самых трудных целей в программировании — создать многократно используемый код.**

**Используя шаблоны, можно создавать обобщенные функции и классы.**

**В обобщенной функции (или классе) обрабатываемый тип данных задается как параметр. Таким образом, одну функцию или класс можно использовать для разных типов данных, не предоставляя явным образом конкретные версии для каждого типа данных.**
___
# Вопросы 74-93

## Вопрос 74

**Шаблоны функций: назначение, определение, применение.**

**Ответ:** 

Шаблоны функций позволяют создать **обобщенную функцию. Обобщенная функция** определяет общий набор операций, которые предназначены для применения к данным различных типов. Тип данных, обрабатываемых функцией, передается ей как параметр. Используя обобщенную функцию, к широкому диапазону данных можно применить единую общую процедуру. Создавая обобщенную функцию, можно определить природу алгоритма независимо от типа данных. После этого компилятор автоматически генерирует корректный код для типа данных, который в действительности используется при выполнении этой функции (если обобщенная функция никак не используется, она вообще не будет затронута компилятором). По сути, создавая обобщенную функцию, вы создаете функцию, которая автоматически перегружает саму себя.

Обобщенная функция создается с помощью ключевого слова `template`.
```c++
template<class Type>
Type _min(Type a, Type b){
    if( a < b) {
        return a;
    }
    return b;
}
```

Примечание: вместо `class` можно использовать `typename`.

`template-спецификация` должна стоять непосредственно перед определением функции. Между ними не может находиться ни инструкция объявления переменной, ни какая-либо другая инструкция.

Также важно понимать, что можно указать несколько обобщенных типов, например:
```c++
template<class Type1, class Type2>
void greeting(Type1 a, Type2 b){
    std::cout << "Hello, Type1 and Type2!" << a << " " << b;
}
```
Type1 и Type2 могут совпадать, а могут и отличаться, в этом и вся прелесть.

Если простыми словами: у нас есть код, которому вообще все равно с каким типом данных работать, а писать одно и то же для каждого типа отдельно никто не станет, это ужасно. Здесь нам и помогают шаблоны - просто вместо конкретного типа используем параметризованный тип, компилятор уже сам решит, какие варианты нужно использовать. Здесь главное, чтобы каждый тип данных, подставляемый в функцию, соответствовал функционалу функции. Например в примере функция ищет минимальное значение среди двух, но если бы мы хотели передать туда свой класс, например `Student`, то нужно было бы определить для него оператор сравнивания `<`.
___
## Вопрос 75

**Что позволяют шаблоны и не позволяет препроцессор Си?**

## Вопрос 76

**Что позволяет препроцессор Си и не позволяют шаблоны?**
    
**Ответы:** 
Во-первых, **препроцессор** - программа, которая подготавливает код программы на языке Си к компиляции (для С++ тоже такое есть, но тут вопрос про Си). 

Я так понимаю, здесь под “позволяет препроцессор Си” имеются в виду **директивы препроцессора**. Для понимания рассмотрим директиву препроцессора для подстановки имен – `define`. 
Два примера использования `define`:
```c++
#define HELLO "Привет!"
#define MIN(a, b) (((a)<(b)) ? a : b) 

int main() {
  int x, y;
  x = 10;
  y = 20;
  cout << HELLO;
  cout << "Минимум равен: " << MIN(x, у);
  return 0;
} 
```

По сути у нас есть какое-то выражение или значение, и мы даем этому делу имя. В программе мы можем использовать это имя везде, где захотим (`define` обычно используется в начале файла).

Так вот, отвечая на вопросы.

Шаблоны позволяют избежать повторов в коде, возлагая выбор, с каким же типом генерировать функцию, на компилятор. Это довольно эффективно по памяти, но время какое-то займет.

`define` скорее же позволяет использовать часто встречающиеся вещи (будь то число, строка или операция) в более короткой форме. В таком случае ещё до компиляции вместо, например,  `HELLO` будет подставлено "Привет!". А в случае с `MIN(a, b)` - оно не работает как функция, на деле строка с выводом перед компиляцией примет следующий вид:
```c++
cout << "Минимум равен: " << (((x)<(y)) ? x : y);
```
Никаких вызовов функции не происходит, происходит текстовая замена перед компиляцией. Это довольно неэффективно по памяти, так как мы могли бы использовать `MIN(a, b)` в других местах, а значит было бы много повторов. Но зато это эффективно по времени - нет вызовов функций. 

Вообще есть различный директивы препроцессора, и, комбинируя их, можно создать подобие функционала `template`. Но в таком случае нам придется заранее знать, с какими конкретными типами будет работать класс или функция. Например, мы можем задать шаблон функции, но для каждого типа придется прописывать что-то вроде: 

Если тип Т не определен - определить его как int и использовать шаблон. 

Если тип Т не определен - определить его как double и использовать шаблон. 

Если… И так далее. ( Думаю можно не вникать в синтаксис, т.к. на чистом Си мы не пишем, но описанные здесь словами действия можно посмотреть в виде кода в этой статье https://habr.com/ru/post/154811/ )

То есть если мы хотим одинаковый рабочий код для 100 различных типов, нам придется явно это указать в коде. Конечно, мы не повторяем саму реализацию 100 раз, но мы указываем все 100 типов, с которыми хотим работать, а это не прикольно.

Я так понимаю, что директивы препроцессора и шаблоны - не абсолютно, но все же разные вещи, которые применяются для своих целей. Отвечая на вопросы, я бы сказал, что делают шаблоны (позволяют избежать повторов), а что делают директивы препроцессора (подготовка кода к компиляции, текстовая подмена кода). 

**Есть сомнение:**
Думаю, что этих представлений будет достаточно для ответа. Если есть что добавить - пишите что именно, а потом будем исправлять.
___
## Вопрос 77

**Правила перегрузки шаблонов: приведите короткие примеры.**
    
**Ответ:** 

Если мы хотим перегрузить шаблон, то достаточно создать еще одну версию шаблона, но уже с другим числом параметров. Рассмотрим пример:
```c++
template <class T>
void same(T s) {
    cout << s << endl;
}

template <class T, class Y>
void same(T s, Y e) {
    cout << s << e << endl;
}
```

Чтобы вызвать первый вариант, можно использовать просто `same(4)`. 
Но чтобы использовать вариант с перегруженным шаблоном, в данном случае подойдет вызов вроде `same(4, “what is it?”)`. 

**Внимание! Ниже приводится перегрузка обобщенной функции, а не перегрузка шаблона. Привожу это в пример, потому что кто знает, может оно тоже сюда.**

Можно использовать _явную специализацию_. Это версия обобщенной функции, когда вместо параметра типа мы подставляем конкретный тип. Это может быть полезно, когда наша обобщенная функция для всех типов работает одинаково, но, например, для `int` должна работать иначе (может для `int` есть более эффективная реализация). В таком случае сигнатура функции остается прежней, включая число и тип параметров, с одним небольшим изменением - параметризованный тип заменяется на конкретный.
Рассмотрим примеры:
```c++
template <class T> 
void swap(T &a, T &b) {
	T temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Общая реализация swap”;
}

void swap(int &a, int &b) {
	int temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Явная int специализация swap”;
}

template <> 
void swap<int>(int &a, int &b) {
	int temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Явная int специализация swap (Этот вариант аналогичен способу выше, но является более современным. Разницы пока никакой, но с развитием языка она может появиться, в книжках рекомендуют именно этот вариант явной специализации)”;
}
```
Также мы можем перегружать обобщенные функции как и обычные - просто изменяя список параметров функции, оставляя сам шаблон неизменным.
___

## Вопрос 78

**Типизированные, нетипизированные и шаблонные параметры шаблонов - назначение и примеры использования.**
    
**Ответ:**     
Параметры шаблона могут быть: `типизированные`, `нетипизированные`, `шаблонные`.
На занятиях мы реализовывали структуры для последовательного хранения данных - `список`, `двусвязный список`, `стек`, `очередь`, `вектор` и тд. Предположим мы хотим сделать класс обертку, который бы мог быть и `списком`, и `вектором`, и `cтеком`, при этом зафиксировать максимальный размер этой структуры. Разумеется, сами структуры могли бы хранить данные любых типов. Как может выглядеть объявление такого класса? Например, так:
```c++
template <template<class> class L = Stack, class T = double, int size = 100>
class SomeData
{ 
  // do something... 
};
```
Что тут происходит?  Сначала мы объявляем шаблон для класса `SomeData`. У этого шаблона объявляем три параметра.

Первый параметр - _шаблонный параметр_. То есть параметр шаблона - это тоже шаблон. Объявляется он как `template<class> class L`. Написав так, мы ожидаем, что в этот параметр будет передан обобщенный класс, у которого всего один параметр типа шаблона. Например `стек`, который мы реализовывали:
```c++
template <class T>
class Stack : public LinkedList<T>
{
  // Stack body...
}
```
Тут видно, что в шаблоне используется только один параметр, поэтому мы можем использовать его. Если бы мы хотели использовать обобщенные классы с двумя и более параметрами типов, то использовали бы `template<class, class, ...> class L`. Иначе переменное число параметров типа в данном случае можно записаться как `template<class...> class L`

Что значит `= Stack`? Это значение по умолчанию, которое примет данный параметр, для примера указан `Stack`.

Дальше мы ждем _типизированный параметр_ шаблона, наш второй параметр. Ему так же можно дать значение по умолчанию, например `double`.

И последний, _нетипизированный параметр_ - в его роли могут выступать целочисленные константы (включая перечисления) или указатели на объекты с внешним связыванием. Чаще всего это все же целочисленная константа, как в нашем случае. Ей тоже можно присвоить значение по умолчанию, в нашем случае 100.
___

## Вопрос 79

**Чем может быть нетипизированный параметр шаблона?**
    
**Ответ:** 

Аргументы, которые передаются параметру, не являющемуся типом, должны содержать либо **целочисленную константу**, либо **указатель или ссылку на глобальную функцию или объект**. Таким образом, эти _"нетиповые"_ параметры следует рассматривать как константы, поскольку их значения не могут быть изменены. И раз уж они константы, о них все известно уже на стадии компиляции.
___

## Вопрос 80

**Всякое ли имя класса может быть передано в типизированный параметр шаблона?**
    
**Ответ:** 

Можно использовать любые имена, кроме зарезервированных, а также если имя параметра шаблона не совпадает с именем шаблона класса, именем функции и именем параметра функции. Также имена параметров шаблона, если их несколько, должны быть разными.
**Вот так делать НЕ НАДО**
```c++
// Зарезервированное имя
template <class bool>
class fail_bool {};

// Имя параметра шаблона совпадает с именем шаблона класса
template <class SomeName>
class SomeName {};

// Имя совпадает с именем функции
template <class fun>
void fun() {}

// Имя совпадает с именем парметра функции
template <class size>
void area(size a, int size) {}

// Имена параметров шаблона совпадают
template <class A, class A>
class some_class {};
```

## Вопрос 81

**Что может получиться из шаблона при подстановке в него всех типизированных и нетипизированных параметров?**
    
**Ответ:** 

Я, честно, не очень понимаю вопрос, но если здесь нужно ответить что-то вроде: шаблонный класс, шаблонная функция ИЛИ если имеется ввиду подстановка конкретных значений, то, наверное, получится конкретная реализация класса / метода. Если вы знаете что здесь нужно отвечать, напишите мне, буду крайне признателен.
___

## Вопрос 82

**Параметры по умолчанию в шаблонах и перегрузка шаблонов: правила задания и выбора используемого шаблона.**

**Ответ:** 
В шаблонах, как уже замечалось ранее, можно устанавливать значения по умолчанию, будь они `типизированные`, `нетипизированные`, `шаблонные`. Главное чтобы параметры со значением по умолчанию стояли последними в списке параметров. Если при использовании шаблона для них не указать значение явно, будет использоваться значение по умолчанию. 

Шаблоны, как и обычные классы - методы можно перегружать. Можем перегружать их, перегружая сам шаблон - изменяя количество параметров шаблона. А можем перегружать, изменяя список параметров, или приводя явную специализацию. Подробнее примеры перегрузок приведены в ответе на `77 вопрос`. 

Как компилятор понимает, какую версию шаблона использовать? Посмотрим на следующий код: 
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}

template <> 
void swap<int>(int &a, int &b) {
	cout << “Явная int специализация swap”;
}

template <> 
void swap<double>(double &a, double &b) {
	cout << “Явная double специализация swap”;
}
```
Если мы захотим вызвать `swap(4,2)`, то сначала будет проверяться, нет ли реализаций `swap` для `int` значений - более специализированного случая. Если такой не найден, будет вестись поиск более общего случая, и так далее, пока не найдется подходящая структура. Если бы мы хотели использовать `double` реализацию, имея все те же числа 4 и 2, мы бы явно указали это так: `swap<double>(4, 2)`.

___

## Вопрос 83

**Шаблоны классов: назначение, определение, применение и правила порождения объектов.**

**Ответ:** 
Шаблоны можно применять к классам, тогда классы становятся `обобщенными`. Еще обобщенный класс называется `шаблоном класса`.

Применяется это, как и для функций - чтобы выделить общий код, который одинаково работает с разными типами.
Например мы хотим создать свой класс - список для хранения данных. Также мы не хотим ограничиваться каким-то определенным типом данных. Вместо того, чтобы переписывать один и тот же функционал для списка под тип данных `int`, `long`, `double`, `Student`, `Car`, `State`...мы добавляем к классу шаблон - точно так же, как и для функции. 

Например, знакомый класс `vector`. Как породить объект этого класса? Синтаксис уже знаком:
```c++
vector<int> v;
```
Где на месте `int` может стоять любой тип данных. В общем виде, после имени класса, в угловых скобках нужно определить тип параметров шаблона для класса.

Какие правила при порождении? Для класса обязательно указывать типы, с которыми работает класс в угловых скобках, без этого программа не знает, с какими данными ей работать. Ну еще это обязательно должен быть тип данных, примитивный или пользовательский, мы не можем передать в параметр шаблона ссылку на функцию. **Также в угловых скобках обязательно передавать константу**.

___

## Вопрос 84

**Способы порождения функций и классов из шаблонов. Приведите короткие примеры.**
    
**Ответ:** 

Рассмотрим порождение **функции**: 
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}
```
Можем использовать ее, явно не указывая, с каким типом работает функция, в таком случае тип определяется автоматически по типу аргументов функции:
`swap(3.1, 5.23);`

Можем указать тип параметра шаблона явно, используя угловые скобки:
`swap<int>(3, 45);`

Порождение `класса` всегда сопровождается указанием типа в угловых скобках, за исключением случаев, когда предусмотрены значения по умолчанию:
```c++
vector<int> v;
```
Если память выделяется _динамически_, то объявление выглядит так:
```c++
vector<int>* v = new vector<int>();
```
Обратить здесь нужно внимание на то, что угловые скобки используются повторно. Также важно заметить, что указывать тип в обеих скобках обязательно - причем он должен строго совпадать.

___

## Вопрос 85

**Уточнение (спецификация, перегрузка) шаблонов: назначение, выяснение, какой шаблон будет в каком случае использован.**
    
**Ответ:** 

Виды и примеры спецификации (явной специализации) приведены в ответе на 77 вопрос. Шаблоны одинаково перегружаются для методов и классов, поэтому этих примеров будет достаточно для понимания. 

Зачем это нужно?

В случае со спецификацией - применяется в основном, если мы хотим отойти от шаблонного кода для какого-то определенного типа (это может быть связано с наличием более эффективного решения для данного типа).

В случае с перегрузкой - используется точно в тех же случаях, когда нам в принципе нужна перегрузка, когда нам нужно поменять параметры, но функционал остается тем же. Только тут еще используются шаблоны.

Рассмотрим пример:
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}

void swap(int &a, int &b) {
	cout << “Явная int специализация swap”;
}
```
Хотим вызвать `swap(2.2, 4.21)`. Сначала ищется вариант с более конкретными параметрами - ищется метод `swap`, принимающий два `double`. Если таких не было найдено, то ищется более общий случай - шаблонный. Вот здесь он найдет нужный вариант и отработает по нему. Грубо говоря, когда идет поиск нужного варианта, программа движется вверх по иерархии - от более специализированного, до более общего случая. 

___

## Вопрос 86

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

Да, в общем то, никак. У функции главное поменять набор параметров или их тип, тогда она и будет перегружена.

Для обобщенных функций главное помнить, что у них есть перегрузка в виде изменеий параметров, а есть специализация, которая была рассмотрена в ответе на 77 вопрос.

Также можно перегружать сами шаблоны, изменяя число параметров шаблона или их тип. Пару примеров:
```c++
// обобщенная функция
template <class T> 
T bor(T a) {
	cout << "T bor\n";
}

// ее специализация
template<>
int bor<int>(int a) {
	cout << "void bor\n";
}

// изменение параметров + типа возвращаемого значения
template <class T>
void bor(T a, double d) {
	cout << "void bor\n";
}

// используем нетипизированный параметр вместо типизированного
template <int n>
int bor(int a) {
	cout << "non-type bor\n";
}
```

___

## Вопрос 87

**Средства динамического выделения/освобождения памяти и их отличие от конструктора и деструктора.**
    
**Ответ:** 

Когда используются _конструкторы_ или _деструкторы_, мы работаем с `статической областью памяти`, иначе - со `стеком`. В этом случае программа заранее знает, сколько места нужно выделить под объекты и уже на стадии компиляции выделяет для них память, а также очень просто удаляет из этой же памяти, когда программа прекращает свою работу.

В случае с _динамическим выделением памяти_ `(new)` и _динамического освобождения памяти_ `(delete)`, мы запрашиваем место у оперативной памяти, которая располагается вне нашей программы.

По сути главные отличия следующие:
+ динамическое выделение/особождение памяти - работа с оперативной памятью, а конструкторы и деструкторы работают со статической памятью. 
+ используя `new` мы получаем _указатель_ на объект, а не сам объект, как в случае с конструктором
+ деструктор сработает автоматически по завершении программы, но в случае с динамическим освобождением памяти, нам необходимо самостоятельно заботиться о запрошенной памяти, поэтому мы сами должны вызвать `delete`, после того как память нам больше не нужна, иначе может произойти _утечка памяти_. По завершении программы оперативная память все равно очистит весь мусор, но если мы увлечемся, то программа может аварийно завершится, а это явно не то, что нам нужно.
___

## Вопрос 88

**Стандартные средства динамического выделения / освобождения памяти и наследование: что будет использовано, если имеется перегрузка new / delete в базовом / порождённом классе?**
    
**Ответ:** 

Возможно тут все как в обычном наследовании.

Отвечу на этот вопрос позже, когда разоберусь, как устроена перегрузка `new` и `delete`. Вероятно тут есть подводные камни.

___

## Вопрос 89

**Пространства имён: определение, использование, наименование, вложенность.**
    
**Ответ:** 

Пространства имен - это, по сути, граница, оболочка для кода, у которой есть название. Можно представить ее как папку в файловой системе, в которой лежат файлы нашего кода. Но, конечно, это просто аналогия. Зачем они нужны? Представьте два человека, которые никогда не общались друг с другом, пишут программу (ну вот так). Каждый реализовывает свой функционал, но что если названия, например, функций где-то совпадут? Тогда им нужно заговорить друг с другом (а они этого не хотят) и договориться о новых именах. А если такое происходит регулярно? Вот в такие моменты поможет использование пространства имен. Мы обертываем код внутри пространства имен, и теперь можем обращаться к нашему коду через имя название его пространства имен, что позволяет избежать неоднозначность. Мы точно будем знать, чей код используем: Васи или Пети. Посмотрим на код ниже: 
```c++
namespace Vasya
{
    class Stack
    {
    public:
        int t;

        void print()
        {
            t = 1000000;
            cout << t << " amazing cats!\n";
        }
    };

    template <class T>
    class Madara
    {
    public:
        T raz;
        void haha()
        {
            cout << "haha stupid naruto, using\n" << raz;
        }
    };

    int foo() {
        return 4;
    }

    int foo(int x) {
        return x + 3;
    }

    double it_is_euler_number_yes_it_is_not_pi = 3.14;
}
```
Что? Объявлено пространство имен с названием `Vasya`, для этого было использовано `namespace Vasya {...}`. Название может быть любым, не зарезервированным `с++`. Внутри пространства имен могут располагаться переменные, функции, классы...или другие пространства имен. В общем-то, это что-то вроде оболочки для ваших классов, функций и переменных. На них не накладываются никакие новые ограничения. Теперь, если бы у Пети был точно такой же код, но с другой реализацией, мы бы могли разрешить неоднозначность, в этом нам и помогли пространства имен. Как это разрешение реализуется? Использованием названия п.имен перед используемыми функциями, классами, переменными. Выглядит это так:
```c++
int main()
{
    Vasya::foo();

    Vasya::Madara<int> madara();

    double euler_yes = Vasya::it_is_euler_number_yes_it_is_not_pi;
}
```
Перед использованием чего-либо, мы сначала указываем название пространства имен, из которого хотим взять нужное что-то, а затем ставим `::`, после чего само что-то. Вот так все просто. А. Еще внутри пространства имен можно указать еще одно пространство имен, которое будет вложенным. Тогда, обращаясь к коду, мы должны указать через двоеточие всю цепочку вложенности. Например: 
```c++
namespace first {
    namespace second {
        void foo() {
            cout << "hello, have you a good day";
        }
    }
}

int main()
{
    first::second::foo();
}
```

Пожалуй здесь скажу еще об одной возможности. Если мы уверены, что код внутри пространства имен никак не будет конфликтовать с нашим кодом через имена переменных, функций и тд, то можно избавить себя от постоянного упоминания `Vasya::some_code`, и использовать `using namespace Vasya`. В таком случае весь код, который располагался в `namespace Vasya` будто бы встроится в наш код, как в родной, и мы будем иметь возможность обращаться к нему так же, как если бы сами его написали у себя в программе. Мы уже использовали это, например `using namespace std` дает нам возмодность использовать переменные и функции из пространства имен std.

___

## Вопрос 90

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

___

## Вопрос 91
 
**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:**

___

## Вопрос 92

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:**

___

## Вопрос 93

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:**
