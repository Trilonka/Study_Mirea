# Шаблоны С++

**Шаблоны позволяют достичь одну из самых трудных целей в программировании — создать многократно используемый код.**

**Используя шаблоны, можно создавать обобщенные функции и классы.**

**В обобщенной функции (или классе) обрабатываемый тип данных задается как параметр. Таким образом, одну функцию или класс можно использовать для разных типов данных, не предоставляя явным образом конкретные версии для каждого типа данных.**
___
# Вопросы 74-93

## Вопрос 74

**Шаблоны функций: назначение, определение, применение.**

**Ответ:** 

Шаблоны функций позволяют создать **обобщенную функцию. Обобщенная функция** определяет общий набор операций, которые предназначены для применения к данным различных типов. Тип данных, обрабатываемых функцией, передается ей как параметр. Используя обобщенную функцию, к широкому диапазону данных можно применить единую общую процедуру. Создавая обобщенную функцию, можно определить природу алгоритма независимо от типа данных. После этого компилятор автоматически генерирует корректный код для типа данных, который в действительности используется при выполнении этой функции (если обобщенная функция никак не используется, она вообще не будет затронута компилятором). По сути, создавая обобщенную функцию, вы создаете функцию, которая автоматически перегружает саму себя.

Обобщенная функция создается с помощью ключевого слова `template`.
```c++
template<class Type>
Type _min(Type a, Type b){
    if( a < b) {
        return a;
    }
    return b;
}
```

Примечание: вместо `class` можно использовать `typename`.

`template-спецификация` должна стоять непосредственно перед определением функции. Между ними не может находиться ни инструкция объявления переменной, ни какая-либо другая инструкция.

Также важно понимать, что можно указать несколько обобщенных типов, например:
```c++
template<class Type1, class Type2>
void greeting(Type1 a, Type2 b){
    std::cout << "Hello, Type1 and Type2!" << a << " " << b;
}
```
Type1 и Type2 могут совпадать, а могут и отличаться, в этом и вся прелесть.

Если простыми словами: у нас есть код, которому вообще все равно с каким типом данных работать, а писать одно и то же для каждого типа отдельно никто не станет, это ужасно. Здесь нам и помогают шаблоны - просто вместо конкретного типа используем параметризованный тип, компилятор уже сам решит, какие варианты нужно использовать. Здесь главное, чтобы каждый тип данных, подставляемый в функцию, соответствовал функционалу функции. Например в примере функция ищет минимальное значение среди двух, но если бы мы хотели передать туда свой класс, например `Student`, то нужно было бы определить для него оператор сравнивания `<`.
___
## Вопрос 75

**Что позволяют шаблоны и не позволяет препроцессор Си?**

## Вопрос 76

**Что позволяет препроцессор Си и не позволяют шаблоны?**
    
**Ответы:** 
Во-первых, **препроцессор** - программа, которая подготавливает код программы на языке Си к компиляции (для С++ тоже такое есть, но тут вопрос про Си). 

Я так понимаю, здесь под “позволяет препроцессор Си” имеются в виду **директивы препроцессора**. Для понимания рассмотрим директиву препроцессора для подстановки имен – `define`. 
Два примера использования `define`:
```c++
#define HELLO "Привет!"
#define MIN(a, b) (((a)<(b)) ? a : b) 

int main() {
  int x, y;
  x = 10;
  y = 20;
  cout << HELLO;
  cout << "Минимум равен: " << MIN(x, у);
  return 0;
} 
```

По сути у нас есть какое-то выражение или значение, и мы даем этому делу имя. В программе мы можем использовать это имя везде, где захотим (`define` обычно используется в начале файла).

Так вот, отвечая на вопросы.

Шаблоны позволяют избежать повторов в коде, возлагая выбор, с каким же типом генерировать функцию, на компилятор. Это довольно эффективно по памяти, но время какое-то займет.

`define` скорее же позволяет использовать часто встречающиеся вещи (будь то число, строка или операция) в более короткой форме. В таком случае ещё до компиляции вместо, например,  `HELLO` будет подставлено "Привет!". А в случае с `MIN(a, b)` - оно не работает как функция, на деле строка с выводом перед компиляцией примет следующий вид:
```c++
cout << "Минимум равен: " << (((x)<(y)) ? x : y);
```
Никаких вызовов функции не происходит, происходит текстовая замена перед компиляцией. Это довольно неэффективно по памяти, так как мы могли бы использовать `MIN(a, b)` в других местах, а значит было бы много повторов. Но зато это эффективно по времени - нет вызовов функций. 

Вообще есть различный директивы препроцессора, и, комбинируя их, можно создать подобие функционала `template`. Но в таком случае нам придется заранее знать, с какими конкретными типами будет работать класс или функция. Например, мы можем задать шаблон функции, но для каждого типа придется прописывать что-то вроде: 

Если тип Т не определен - определить его как int и использовать шаблон. 

Если тип Т не определен - определить его как double и использовать шаблон. 

Если… И так далее. ( Думаю можно не вникать в синтаксис, т.к. на чистом Си мы не пишем, но описанные здесь словами действия можно посмотреть в виде кода в этой статье https://habr.com/ru/post/154811/ )

То есть если мы хотим одинаковый рабочий код для 100 различных типов, нам придется явно это указать в коде. Конечно, мы не повторяем саму реализацию 100 раз, но мы указываем все 100 типов, с которыми хотим работать, а это не прикольно.

Я так понимаю, что директивы препроцессора и шаблоны - не абсолютно, но все же разные вещи, которые применяются для своих целей. Отвечая на вопросы, я бы сказал, что делают шаблоны (позволяют избежать повторов), а что делают директивы препроцессора (подготовка кода к компиляции, текстовая подмена кода). 

**Есть сомнение:**
Думаю, что этих представлений будет достаточно для ответа. Если есть что добавить - пишите что именно, а потом будем исправлять.
___
## Вопрос 77

**Правила перегрузки шаблонов: приведите короткие примеры.**
    
**Ответ:** 

Если мы хотим перегрузить шаблон, то достаточно создать еще одну версию шаблона, но уже с другим числом параметров. Рассмотрим пример:
```c++
template <class T>
void same(T s) {
    cout << s << endl;
}

template <class T, class Y>
void same(T s, Y e) {
    cout << s << e << endl;
}
```

Чтобы вызвать первый вариант, можно использовать просто `same(4)`. 
Но чтобы использовать вариант с перегруженным шаблоном, в данном случае подойдет вызов вроде `same(4, “what is it?”)`. 

**Внимание! Ниже приводится перегрузка обобщенной функции, а не перегрузка шаблона. Привожу это в пример, потому что кто знает, может оно тоже сюда.**

Можно использовать _явную специализацию_. Это версия обобщенной функции, когда вместо параметра типа мы подставляем конкретный тип. Это может быть полезно, когда наша обобщенная функция для всех типов работает одинаково, но, например, для `int` должна работать иначе (может для `int` есть более эффективная реализация). В таком случае сигнатура функции остается прежней, включая число и тип параметров, с одним небольшим изменением - параметризованный тип заменяется на конкретный.
Рассмотрим примеры:
```c++
template <class T> 
void swap(T &a, T &b) {
	T temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Общая реализация swap”;
}

void swap(int &a, int &b) {
	int temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Явная int специализация swap”;
}

template <> 
void swap<int>(int &a, int &b) {
	int temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Явная int специализация swap (Этот вариант аналогичен способу выше, но является более современным. Разницы пока никакой, но с развитием языка она может появиться, в книжках рекомендуют именно этот вариант явной специализации)”;
}
```
Также мы можем перегружать обобщенные функции как и обычные - просто изменяя список параметров функции, оставляя сам шаблон неизменным.
___

## Вопрос 78

**Типизированные, нетипизированные и шаблонные параметры шаблонов - назначение и примеры использования.**
    
**Ответ:**     
Параметры шаблона могут быть: `типизированные`, `нетипизированные`, `шаблонные`.
На занятиях мы реализовывали структуры для последовательного хранения данных - `список`, `двусвязный список`, `стек`, `очередь`, `вектор` и тд. Предположим мы хотим сделать класс обертку, который бы мог быть и `списком`, и `вектором`, и `cтеком`, при этом зафиксировать максимальный размер этой структуры. Разумеется, сами структуры могли бы хранить данные любых типов. Как может выглядеть объявление такого класса? Например, так:
```c++
template <template<class> class L = Stack, class T = double, int size = 100>
class SomeData
{ 
  // do something... 
};
```
Что тут происходит?  Сначала мы объявляем шаблон для класса `SomeData`. У этого шаблона объявляем три параметра.

Первый параметр - _шаблонный параметр_. То есть параметр шаблона - это тоже шаблон. Объявляется он как `template<class> class L`. Написав так, мы ожидаем, что в этот параметр будет передан обобщенный класс, у которого всего один параметр типа шаблона. Например `стек`, который мы реализовывали:
```c++
template <class T>
class Stack : public LinkedList<T>
{
  // Stack body...
}
```
Тут видно, что в шаблоне используется только один параметр, поэтому мы можем использовать его. Если бы мы хотели использовать обобщенные классы с двумя и более параметрами типов, то использовали бы `template<class, class, ...> class L`. Иначе переменное число параметров типа в данном случае можно записаться как `template<class...> class L`

Что значит `= Stack`? Это значение по умолчанию, которое примет данный параметр, для примера указан `Stack`.

Дальше мы ждем _типизированный параметр_ шаблона, наш второй параметр. Ему так же можно дать значение по умолчанию, например `double`.

И последний, _нетипизированный параметр_ - в его роли могут выступать целочисленные константы (включая перечисления) или указатели на объекты с внешним связыванием. Чаще всего это все же целочисленная константа, как в нашем случае. Ей тоже можно присвоить значение по умолчанию, в нашем случае 100.
___

## Вопрос 79

**Чем может быть нетипизированный параметр шаблона?**
    
**Ответ:** 

Аргументы, которые передаются параметру, не являющемуся типом, должны содержать либо **целочисленную константу**, либо **указатель или ссылку на глобальную функцию или объект**. Таким образом, эти _"нетиповые"_ параметры следует рассматривать как константы, поскольку их значения не могут быть изменены. И раз уж они константы, о них все известно уже на стадии компиляции.
___

## Вопрос 80

**Всякое ли имя класса может быть передано в типизированный параметр шаблона?**
    
**Ответ:** 

Можно использовать любые имена, кроме зарезервированных, а также если имя параметра шаблона не совпадает с именем шаблона класса, именем функции и именем параметра функции. Также имена параметров шаблона, если их несколько, должны быть разными.
**Вот так делать НЕ НАДО**
```c++
// Зарезервированное имя
template <class bool>
class fail_bool {};

// Имя параметра шаблона совпадает с именем шаблона класса
template <class SomeName>
class SomeName {};

// Имя совпадает с именем функции
template <class fun>
void fun() {}

// Имя совпадает с именем парметра функции
template <class size>
void area(size a, int size) {}

// Имена параметров шаблона совпадают
template <class A, class A>
class some_class {};
```

## Вопрос 81

**Что может получиться из шаблона при подстановке в него всех типизированных и нетипизированных параметров?**
    
**Ответ:** 

В чем суть вопроса? Малиновый пирог.
___

## Вопрос 82

**Параметры по умолчанию в шаблонах и перегрузка шаблонов: правила задания и выбора используемого шаблона.**

**Ответ:** 
В шаблонах, как уже замечалось ранее, можно устанавливать значения по умолчанию, будь они `типизированные`, `нетипизированные`, `шаблонные`. Главное чтобы параметры со значением по умолчанию стояли последними в списке параметров. Если при использовании шаблона для них не указать значение явно, будет использоваться значение по умолчанию. 

Шаблоны, как и обычные классы - методы можно перегружать. Можем перегружать их, перегружая сам шаблон - изменяя количество параметров шаблона. А можем перегружать, изменяя список параметров, или приводя явную специализацию. Подробнее примеры перегрузок приведены в ответе на `77 вопрос`. 

Как компилятор понимает, какую версию шаблона использовать? Посмотрим на следующий код: 
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}

template <> 
void swap<int>(int &a, int &b) {
	cout << “Явная int специализация swap”;
}

template <> 
void swap<double>(double &a, double &b) {
	cout << “Явная double специализация swap”;
}
```
Если мы захотим вызвать `swap(4,2)`, то сначала будет проверяться, нет ли реализаций `swap` для `int` значений - более специализированного случая. Если такой не найден, будет вестись поиск более общего случая, и так далее, пока не найдется подходящая структура. Если бы мы хотели использовать `double` реализацию, имея все те же числа 4 и 2, мы бы явно указали это так: `swap<double>(4, 2)`.

___

## Вопрос 83

**Шаблоны классов: назначение, определение, применение и правила порождения объектов.**

**Ответ:** 
Шаблоны можно применять к классам, тогда классы становятся `обобщенными`. Еще обобщенный класс называется `шаблоном класса`.

Применяется это, как и для функций - чтобы выделить общий код, который одинаково работает с разными типами.
Например мы хотим создать свой класс - список для хранения данных. Также мы не хотим ограничиваться каким-то определенным типом данных. Вместо того, чтобы переписывать один и тот же функционал для списка под тип данных `int`, `long`, `double`, `Student`, `Car`, `State`...мы добавляем к классу шаблон - точно так же, как и для функции. 

Например, знакомый класс `vector`. Как породить объект этого класса? Синтаксис уже знаком:
```c++
vector<int> v;
```
Где на месте `int` может стоять любой тип данных. В общем виде, после имени класса, в угловых скобках нужно определить тип параметров шаблона для класса.

Какие правила при порождении? Для класса обязательно указывать типы, с которыми работает класс в угловых скобках, без этого программа не знает, с какими данными ей работать. Ну еще это обязательно должен быть тип данных, примитивный или пользовательский, мы не можем передать в параметр шаблона ссылку на функцию. **Также в угловых скобках обязательно передавать константу**.

___

## Вопрос 84

**Способы порождения функций и классов из шаблонов. Приведите короткие примеры.**
    
**Ответ:** 

Рассмотрим порождение **функции**: 
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}
```
Можем использовать ее, явно не указывая, с каким типом работает функция, в таком случае тип определяется автоматически по типу аргументов функции:
`swap(3.1, 5.23);`

Можем указать тип параметра шаблона явно, используя угловые скобки:
`swap<int>(3, 45);`

Порождение `класса` всегда сопровождается указанием типа в угловых скобках, за исключением случаев, когда предусмотрены значения по умолчанию:
```c++
vector<int> v;
```
Если память выделяется _динамически_, то объявление выглядит так:
```c++
vector<int>* v = new vector<int>();
```
Обратить здесь нужно внимание на то, что угловые скобки используются повторно. Также важно заметить, что указывать тип в обеих скобках обязательно - причем он должен строго совпадать.

___

## Вопрос 85

**Уточнение (спецификация, перегрузка) шаблонов: назначение, выяснение, какой шаблон будет в каком случае использован.**
    
**Ответ:** 

Виды и примеры спецификации (явной специализации) приведены в ответе на 77 вопрос. Шаблоны одинаково перегружаются для методов и классов, поэтому этих примеров будет достаточно для понимания. 

Зачем это нужно?

В случае со спецификацией - применяется в основном, если мы хотим отойти от шаблонного кода для какого-то определенного типа (это может быть связано с наличием более эффективного решения для данного типа).

В случае с перегрузкой - используется точно в тех же случаях, когда нам в принципе нужна перегрузка, когда нам нужно поменять параметры, но функционал остается тем же. Только тут еще используются шаблоны.

Рассмотрим пример:
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}

void swap(int &a, int &b) {
	cout << “Явная int специализация swap”;
}
```
Хотим вызвать `swap(2.2, 4.21)`. Сначала ищется вариант с более конкретными параметрами - ищется метод `swap`, принимающий два `double`. Если таких не было найдено, то ищется более общий случай - шаблонный. Вот здесь он найдет нужный вариант и отработает по нему. Грубо говоря, когда идет поиск нужного варианта, программа движется вверх по иерархии - от более специализированного, до более общего случая. 

___

## Вопрос 86

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

Да, в общем то, никак. У функции главное поменять набор параметров или их тип, тогда она и будет перегружена.

Для обобщенных функций главное помнить, что у них есть перегрузка в виде изменеий параметров, а есть специализация, которая была рассмотрена в ответе на 77 вопрос.

Также можно перегружать сами шаблоны, изменяя число параметров шаблона или их тип. Пару примеров:
```c++
// обобщенная функция
template <class T> 
T bor(T a) {
	cout << "T bor\n";
}

// ее специализация
template<>
int bor<int>(int a) {
	cout << "void bor\n";
}

// изменение параметров + типа возвращаемого значения
template <class T>
void bor(T a, double d) {
	cout << "void bor\n";
}

// используем нетипизированный параметр вместо типизированного
template <int n>
int bor(int a) {
	cout << "non-type bor\n";
}
```

___

## Вопрос 87

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

___

## Вопрос 88

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

___

## Вопрос 89

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

___

## Вопрос 90

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

___

## Вопрос 91

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:**

___

## Вопрос 92

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:**

___

## Вопрос 93

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:**
