**Объявление** - выделение памяти под объект.  
За объявление отвечают аллокаторы(не совсем точная инфа, ведь есть и другие штучки, отвечающие за выделение памяти)


**Присваивание** - задание значений для полей объекта.  
За присваивание отвечает `operator=`

**Инициализация** - объявление + присваивание одновременно.  
За инициализацию отвечают конструкторы.

___
## Вопрос 100

**Инициализация объектов классов, перечислите все её способы и проиллюстрируйте примерами.**

> [Инициализация в C++](https://hsto.org/r/w1560/webt/bp/rd/ow/bprdow1rk6jtw5fzpm3bffzirps.gif)

**Ответ:** для начала отметим, что тема инициализации в c++ очень глубока и сложна, каждый стандарт содержал дополнения, но тем не менее все еще ведется разработка. Если хотите супер подробно, и  если вам не жалко для этого пары часов, то читайте эту [интересную статью](https://habr.com/ru/company/jugru/blog/469465/). Начнем инциализаций, которые перекочевали в C++ из C.

1.  **Инициализация по умолчанию**
    
    На самом деле это неудачное название для этого вида инициализации, ведь, честно говоря, это даже не совсем инициализация, а больше похоже на объявление. Пример 1
    ```c++
    class Human {
    public:
        int _age;
        int _chromosomes;
    };

    int main() {
        Human chel;
        return chel._age; // неопределенное поведение
    }
    ```
    Мы здесь успользовали вместо `struct` - `class`, а этого вообще-то не было в C, но не будем на этом заострять внимание, просто мы так захотели. Упомянем здесь еще две инициализации. Первая - `member initializer list`, что была добавлена в C++98, вторая - `default member initializers`, что была добавлена в C++11. 
    
    >Пример 2. (Но такое решение проблемы не оптимальное, поскольку это необходимо делать в каждом конструкторе, и об этом легко забыть. Кроме того, инициализация идёт в порядке, в котором переменные объявлены, а не в порядке member initializer list)
     ```c++
    class Human {
    public:
        Human() : age(20), chromosomes(48) {} // member initialiser list
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_;
        int _chromosomes_;
    };

    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >Пример 3. (Позволет инициализировать все переменные одновременно, и это даёт уверенность, что все элементы инициализированы)
    ```c++
        class Human {
    public:
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_ = 20;         // default member initialisers
        int _chromosomes_ = 48; // default member initialisers
    };

    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >(Хабр) Рекомендация: когда можете, всегда используйте DMI (default member initializers).

2. **Копирующая инициализация**
    ```c++
    int variable = 42;
    ```

    В этом случае мы указываем переменную и через знак равенства — её значение. Отметим, что копирующая инициализация также используется, когда аргумент передаётся в функцию по значению, или когда происходит возврат объекта из функции по значению. Мы смотрим на знак равенсва и думаем: "Так это же присвоение значения...". Оказывается, что нет. **Копирующая инициализация — это не присвоение значения. Оператор присваяивания здесь нечего не делает!**
    
3. **Агрегатная инициализация**

    Используется для массивов и агрегатных классов (_т.е. набор публичных полей, объединеных в `class`_). 
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        Human chel {20, 48};   // <=> Human chel = {20, 48};
        std::cout << chel.get_age() << '\n'; // Вывод: 20

        Human chuvak {20}; // остальные значения инициализируются 0
        std::cout << chel.get_chromosomes() << '\n' // Вывод: 0
    }
    ```
    >Агрегатная инициализация на самом деле использует копирующую инициализацию для каждого элемента.

4. **Статическая инициализация**
    
    Шанс, что у вас про это спросят стремится к 0, но для умников и умничек, мы не забили на него. Суть статической инициализации в том, чтобы инициализироавть статический объект (_для этого объекта ппамять выделяется только 1 раз, а существует он на протяжении работы всей программы_) на стадии компиляции (не знаю примера, зачем это нужно).
    
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        static Human chel { 20, 48 };   // <=> Human chel = {20, 48};
        
        std::cout << chel.get_age() << '\n'; // Вывод: 20
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 48
    }
    ```

    Здесь стоит быть аккуратным, поскольку если где-то еще появляется статический объектр, который использует `chel`, возникнет проблема, что первое из них инициализировать, на самом деле это решается через `constexpr`, но мы об этом ничего не знаем, а поскольку ответ на первый вопрос мы пишем уже 3 часай, то разбираться в этом сил нет.

5. **Прямая инициализация**
    
    > До этого момента мы ни разу не использовали конструкторы, потому что все предыдущие инициализации пришли из C, где конструкторов не было.

    Прямая инициализация для базовых типов это абсолютно то же самое, что и копирующая инициализация. Но для пользовательских типов при копирующей инициализации мы не могли сразу инициализировать несоколько атрибутов, а здесь мы можем передать несколько значей, поэтому можем инициализировать несколько полей. Но это не все отличия, чтобы узнать остальные читай [статью](https://habr.com/ru/company/jugru/blog/469465/)

    Пример 4
    ```c++
    class Human {
    public:
        explicit Human (int age = 20, int chromosomes = 48) { // 3 строка
        _age = age;
        _chromosomes = chromosomes;
        };

        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }

        int _age;
        int _chromosomes;
    };

    int main() {
        static Human chel { 8, 47 };   // Вызов конструктора из 3 строки;
        
        std::cout << chel.get_age() << '\n'; // Вывод: 8
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 47
    } 
    ```
    > Кстати скобки `()`, возможно с параметрами, при инциализации всегда вызывают конструктор.

6. [**Инициализация значением**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%B8%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F.-,%D0%98%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20(C%2B%2B03),-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D0%B4%D1%91%D0%BC%20%D0%BA%20%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D1%8E%D1%89%D0%B5%D0%B9)

   **Правило такое: если существует определённый пользователем конструктор по умолчанию, инициализация значением вызывает этот конструктор, в противном случае возвращается нуль.**

7. [**Универсальная инициализация (C++11)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%3D%20default.-,%D0%A3%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20(C%2B%2B11),-%D0%92%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8%20%D0%A1)

8. [**Назначенная инициализация (С++20)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D1%83%D0%BB%D1%83%D1%87%D1%88%D0%B8%D1%82%D1%8C.-,%D0%9D%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20(%D0%A1%2B%2B20),-%D0%A2%D0%B5%D0%BF%D0%B5%D1%80%D1%8C%20%D0%B4%D0%B0%D0%B2%D0%B0%D0%B9%D1%82%D0%B5%20%D0%BF%D0%BE%D0%B3%D0%BE%D0%B2%D0%BE%D1%80%D0%B8%D0%BC)

9. [**Прямая инициализация агрегатных типов (C++20)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%B4%D0%BB%D1%8F%20%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0.-,%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B0%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D0%BD%D1%8B%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20(C%2B%2B20),-%D0%9D%D0%B0%D0%BA%D0%BE%D0%BD%D0%B5%D1%86%2C%20%D0%B2%20%D0%A1) 
___

## Вопрос 101

**Что нужно сделать, чтобы имелась возможность инициализировать значение объекта в месте его определения?**
    
**Ответ:** 

мне кажется, что ждут ответ типа: "если мы говорим про пользовательские классы, то - написать соответсвующий конструктор". Но вы посмотрите на первые 4 пункта из вопроса 100, там нигде явный конструктор не нужен был, компилятор сам создавал свой конструктор для этого. 
> На самом деле, если мы не написали **никакой** конструктор для `struct`, `class`, `union`, то компилятор всегда сможет сделать это сам, при этом запихнет он его в публичнй раздел нашей структуры. См. [здесь](https://en.cppreference.com/w/cpp/language/default_constructor#:~:text=If%20no%20user,of%20its%20class.)

Поэтому мы бы ответили, что "ничего, ибо компилятор позволит нам это сделать".
___

## Вопрос 102

**Можно ли проинициализировать значение объекта в месте его определения без вызова конструктора?**

мы не можем ответить на этот вопрос. 

В в C были структуры, но в C не было конструкторов, поэтому инициализация структур там была без конструкторов. В C++ появились конструкторы, и если мы не объявляли никакого конструктора в нашей структуре (struct, union, class), то за нас это сделает компилятор. Значит ли это, что в C++ теперь нельзя инициализировать структуру совсем без конструктора( и без того, что создаст компилятор )??

___