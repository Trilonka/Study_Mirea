# Здесь представлены ответы на все экзаменационные вопросы по ООП за 2-й семестр. Это общий труд нашей группы, в котором приняли участие:
* [Дарья](https://github.com/Cheburkova)
* [Александра](https://github.com/duddoser)
* [Егор](https://github.com/Marth444)
* [Федор](https://github.com/Droideka501)
* [Николай](https://github.com/Nick440Suvoro)
* [Петр](https://github.com/50657472-416C6578656576)
* [Рустем](https://github.com/Igetsuga)
* [Степан](https://github.com/Trilonka)

## Вопрос 1

**Чем отличается класс от структуры в смысле Си? Как выбрать между классом и структурой в C++?**

**Ответ:** 

Класс — это механизм для создания объектов. Классы представляют собой новые типы данных, которые вводятся в код программистом. 
Обычно пользоваться стандартными типами данных (`int`, `double` и т.п.) для описания какого-либо явления или объекта не удобно, т.к. сложный объект 
характеризуется множеством полей (хранимых данных). Для этого вводятся новые типы, которые зачастую обладают большим количеством полей
(хранимых внутри себя переменных). В этом смысле класс лежит в основе многих свойств C++. 

Класс объявляется с помощью ключевого слова `class`. Синтаксис объявления класса похож на синтаксис объявления структуры. Здесь показана основная форма:

[//]: <> (//////////////////////////////////////////)
[//]: <Рекомендаця по стилю c++> (44. Разделы класса public, protected и private должны быть отсортированы. Все разделы должны быть явно указаны. Сперва должен идти раздел public, что избавит желающих ознакомиться с классом от чтения разделов protected/private.)
[//]: <> (//////////////////////////////////////////)

```c++ 
class имя_класса. {     
public:  
// открытые функции и переменные класса. 
protected:
// список_объектов;
private:
// список_объектов;
};
```
В объявлении класса `список_объектов` не обязателен. Как и в случае со структурой, вы можете объявлять объекты класса позже, по мере необходимости(например, если само определение класса находится в заголовочном файле `.h`, а реализация в файле `.cpp`). 

Вас, возможно, удивило то, что класс и структура имеют фактически одинаковые свойства. В C++ определение структуры расширили таким образом, что туда, 
как и в определение класса, удалось включить функции-члены, в том числе конструкторы и деструкторы. Единственным отличием между структурой 
и классом является то, что **члены класса, по умолчанию, являются закрытыми (private), а члены структуры — открытыми (public).**
Однако **в рамках языка Си структура могла содержать только данные, функции обработки структуры были отделены от объектов структуры.**

Структура объявляется с помощью ключевого слова `struct`. Здесь показан расширенный синтаксис описания структуры:
```c++ 
struct имя_типа {  
// список_объектов
// открытые функции и данные — члены класса.  
private:  
// закрытие функция и данные — члены класса.   
};
```
Таким образом, в соответствии с формальным синтаксисом C++ как структура, так и класс создают новые типы данных. 

Хотя структуры имеют схожие с классами возможности, **большинство программистов ограничивают использование структур взятыми из С формами и не применяют их для задания функций-членов.** Для задания объекта, содержащего данные и код, эти программисты обычно указывают ключевое слово
`class`. Однако все это относится к стилистике и является предметом вашего собственного выбора. 

**ЗАМЕЧАНИЕ. (для тех, кому все-таки интерсно, зачем нужны структуры в рамках C++).** Объяснение этому может быть дано в "строгой" и "мягкой" формах.

* "Строгий" довод состоит в том, что необходимо поддерживать линию на совместимость с С. Стиль задания структур С совершенно допустим и для
программ C++. Поскольку в С все члены структур по умолчанию открыты, это положение также поддерживается и в C++. Кроме этого, поскольку
класс синтаксически отличается от структуры, определение класса открыто для развития в направлении, которое в конечном итоге может привести к
несовместимости со взятым из С определением структуры. Если эти два пути разойдутся, то направление, связанное с C++, уже не будет избыточным.

* "Мягким" доводом в пользу наличия двух сходных конструкций стало отсутствие какого-либо ущерба от расширения определения структуры в C++
таким образом, что в нее стало возможным включение функций-членов.

***

## Вопрос 2

## Что следует оставлять в основном теле определения класса и что разумно выносить из него? Приведите убедительный пример.
___

В данном вопросе рассматриваются только методы класса, так как поля класса мы не можем определить за его границами.
Для примера буду работать с классом `Date`.

```cpp
class Date {
private:
    int y, m, d;
public:
    Date(int y, int m, int d);
    void add_day(int n);
    int month();
}
Date::Date(int yy, int mm, int dd) 
    :y{yy}, m{mm}, d{dd}
void Date::add_day(int n) {
    // определяем
}
int month () {return m;} // ошибка: не указали Date::
```

Определяя методы за пределами класса, мы должны с помощью `::` оператора разрешения области видимости указать, к какому класcу они принадлежат. Для этого используется обозначение *имя_класса* :: *имя_члена*.

**Примечание.** Запись *:y{yy}, m{mm}, d{dd}* представляет собой инициализацию членов класа и называется списком инициализации (членов). 

Метод класса можно также определить прямо в определении класса.
```cpp
class Date {
private:
    int y, m, d;
public:
    Date(int y, int m, int d) {:y{yy}, m{mm}, d{dd}};
    void add_day(int n) {...};
    int month(return m);
}
```

Сразу же отметим, что теперь объявление класса стало больше и запутаннее. В данном примере код конструктора и метода `add_day()` могут содержать десятки строк. Это в несколько раз увеличивает размер обяъвления класса и затрудняет поиск интерфейса среди деталей реализации. Поэтому мы не рекомендуем определять большие функции в объявлении класса. Соответсвенно определения коротких и простых функций можно размещать в объявлении класса. 

Определение метода в классе приводит к следующим последствиям:
1. Метод становится встраиваемым (_inline_), т.е. компилятор будет пытаться вместо вызова метода генерировать его код. Это может дать значительное преимущество в производительности для часто вызываемых методов, таких как `month()`. 

[//]: <> (1. Если класс экспортируется из других модулей, то методы из него уже не будут встроенными. С оптимизацией все очень сомнительно. [Статья - https://habr.com/ru/company/otus/blog/561772/. "Сегодня `inline` - это про one definition rule, а не про inline expansion оптимизацию." ) 

2. При изменении тела встраиваемого метода придется перекомпилировать заново все модули, в которых он используется. Если тело метода определено за пределами объявления класса, то потребуется перекомплировать только само определение класса. Отсутствие необходимости повторной компиляции при изменении тела функции может оказаться важным преимуществом в больших программах.

3. Определение класса становится больше по размеру. Следавательно, будет сложнее находить требуемые члены среди определений методов. То есть приводит к нечитабельности кода.

Очевидное правило глассит: не размещайте тела методов в объявлении класса, если вам не нужна повышенная эффективность программы за счет использования небольших встраиваемых методов. Большие методы, состоящие из пяти и более строк, ничего не выиграют от подстановки. Не сладует делать встраиваемыми метода, содержащие более одного-двух выражений.


[//]: <> (Рекомендация 36 из https://habr.com/ru/post/172091/. Т.е. в в модуле .h определения класса лучше держать только объявления методов, а их реализации в другом .cpp модуле)


P. S. В данном вопросе я использовала "метод" вместо "функции-члена", поскольку чаще используют это слово.

P. S. S. Вопрос - кринж. Будь я экзаменатором убрала бы его, тем более, что на практиках мы вроде нечасто (либо совсем) не использовали объявление методов вне класса. Как по мне, это абсолютно не делает код читабельнее, а только вносит неразбериху, но ответ сделан со ссылкой на Страуструпа.

***

## Вопрос 3

**Могут ли разные части определения класса находиться в разных файлах?**

Да, например сам класс и его методы (прототипы) класса могут быть описан в файле test.h. А описание методов класса и главная функция в файле test.cpp (в другом файле, вне класса). (Как мы делали на семинарах, любая программа может быть примером) (Файл Коли Горшкова)

***

## Вопрос 4

**Пространство имён класса. Как обращаться к членам класса: а) изнутри него, б) извне класса, в) из производных классов?** 

```c++
#include <iostream>
using namespace std;

//Вопрос 4

//Как из класса обращаться к членам класса?
//"ответ на этот вопрос приведён в классе test"

//Как извне класса обращаться к членам класса?
//"ответ приведён в main"

//Как из производных классов обращаться к членам класса?
//"ответ на этот вопрос приведён в классе isp"

class test
{   
    //Как из класса обращаться к членам класса?
    public:
        //чтобы из класса обратиться к членам класса нам не обязательно создавать объект класса
        //можем просто использовать поля и методы данного класса внутри него (без ".")
        int a = 10;
        int b = 55;

        int func2()
        {
            return func1();
        }

    private:
        int c = 33;

        int func1()
        {
            cout << c << endl;
            return b;
        }
};

class isp : public test
{
    public:
        int d = 1;
        int f = 4;
        //по факту тут всё так же, как и "Как из класса обращаться к членам класса?"
        //чтобы из производного класса обратиться к членам класса - родителя нам не обязательно создавать объект какого-то класса
        //можем просто использовать поля и методы класса - родителя внутри производного, если они не лежат в классе - родителе в private
        int funcISP ()
        {
            cout << d << endl;
            cout << d+f << endl;
            return func2();
        }

};

int main()
{
    //Как извне класса обращаться к членам класса?
    test t;
    //для этого необходимо создать объект данного класса
    //и дальнейшие операции производить через обращение на метод или поле (через ".")
    cout << t.a << endl;
    cout << t.func2() << endl;

    isp tt;
    cout << tt.funcISP();
}
```
***

## Вопрос 5

**Можно ли внутри определения класса полноценно пользоваться объектами этого класса?**
```c++
#include <iostream>
using namespace std;

//Вопрос 5
//Можно ли внутри определения класса полноценно пользоваться объектами этого класса ?

// Внутри определения класса полноценно пользоваться объектами этого класса нельзя
// обоснование приведено в классе test

// Но на консультации стало известно, что многие вопросы, которые даже выглядят как "да - нет",
// такими не являются, препод ждёт беседу на тему данного вопроса

class test
{
public:
    int a = 1;
    int b;
    int c = 5;

    test()
    {
        cout << "опять работа" << endl;
    }

    ~test()
    {
        cout << "нужно больше золота" << endl;
    }

    // попробуем задать поле данного класса с помощью объекта данного класса
    //test p;
    // компилятор сразу заругается
    
    //А вот указатель на объект может быть полем этого типа
    test* pp;
    //Для чего это нужно - рассматривалось в практической работе по ООП номер 6, class Element{};
};

int main()
{   
    setlocale(LC_ALL, "ru");
    cout << "я работаю" << endl;
    test t;

}
```

***

## Вопрос 6
**Доступ к членам класса: спецификаторы private, protected, public, дружественные функции.**
```c++
#include <iostream>
using namespace std;

//Вопрос 6

//Доступ к членам класса: спецификаторы private, protected, public, дружественные функции.
//"ответ на этот вопрос приведён в классе test"

class test
{   
    friend void frnd(test &);

    //Члены класса, объявленные как public могут использоваться в любом месте и любой функцией
    public:
        int a = 11;

        int func1()
        {   
            cout << 1 << endl;
            return 1;
        }

    //Члены класса, объявленные как private могут использоваться только функциями класса и друзьями (классами или функциями) класса.
    private:
        int b = 22;

        int func2()
        {   
            cout << 2 << endl;
            return 2;
        }

    //Члены класса, объявленные как protected могут использоваться функциями класса и друзьями (классами или функциями) класса. 
    //Кроме того, они могут использоваться производными классами данного класса.
    // пример приведён в классе pri
    protected:
        int c = 33;

        int func3()
        {
            cout << 3 << endl;
            return 3;
        }
};

//дружественные функции иогут обращаться к полям private, protected, public
void frnd(test &per)
{
    per.func1();
    per.func2();
    per.func3();
}

class pri : public test
{   
    public:
        int func44()
        {
            cout << c << "+" << a << "=" << c + a << endl;
            return 0;
        }
};

int main()
{   
    test p;
    frnd(p);
    pri pp;
    pp.func44();
    cout << "end";
}
```

***

## Вопрос 7

## Понятие интерфейса класса: что нежелательно туда выносить? Почему?	
___

**Интерфейс** - набор методов и атрибутов класса. 

Интерфейсным классом называется класс, не имеющий данных и состоящий в основном из чисто виртуальных функций. Такое решение позволяет полностью отделить реализацию от интерфейса — клиент использует интерфейсный класс, — в другом месте создается производный класс, в котором переопределяются чисто виртуальные функции и определяется функция-фабрика. Детали реализации полностью скрыты от клиента. Таким образом реализуется истинная инкапсуляция, невозможная при использовании обычного класса. 

**Пример**
```cpp
class IErrorLog {
public:
    virtual void openLog(const char *filename) = 0;
    virtual void closeLog() = 0;
    virtual void writeError(const char *errorMessage) = 0;
    virtual ~IErrorLog() {}; // создаем виртуальный деструктор, чтобы вызывался соответствующий деструктор дочернего класса в случае, если удалим указатель на IErrorLog
};
class FileErrorLog : public IErrorLog {
public:
    virtual void openLog(const char *filename) {
        cout << "Writting in file: " << filename << endl;
    }
    virtual void closeLog() {
        cout << "Closing Log" << endl;
    }
    virtual void writeError(const char *errorMessage) {
        cout << "Current error: " << errorMessage << endl;
    }
    virtual ~FileErrorLog() {cout << "FileErrorLog destructor" << endl;}
};
```

[//]: <> (Объясни, пожалуйста, почему у тебя в переопределенных функциях ничего не возвращается, хотя тип возвращаемого значения объявлен как `bool`, но при этом код компилируется)

Любой класс, который наследует `IErrorLog`, должен предоставить свою реализацию всех 3 методов класса `IErrorLog`.

В интерфейс нежелательно выносить функции, которые мы не будем переопределять. Это не имеет смысла: в интерфейсе определены общие методы для группы классов, соответственно уникальные для каждого класса методы нет необходимости определять в интерфейсе. Но это чисто мой ответ, я не понимаю, что хочет услышать Петрусевич.

[//]: <> (Как по мне, отличный ответ) 

***

## Вопрос 8
**Устройство записи определения класса в самом общем виде: возможности.**

https://wiki.dieg.info/opredelenie_klassa_i_sozdanie_ego_obekta

```c++
// объявление классов в С++
class /*имя класса*/
{
  private:
  /* список свойств и методов для использования внутри класса */
  public:
  /* список методов доступных другим функциям и объектам программы */
  protected:
  /*список средств, доступных при наследовании*/
};
```

***

## Вопрос 9

**Может ли один класс включен внутрь другого несколько раз?**

Не может так как выдает ошибку. Например при такой программе:

```c++
#include <iostream>
using namespace std;
 
class List
{
    public:
        List(): head(nullptr), tail(nullptr) {}
    private:
        class Node
        {
              public:
                  int   data;
                  Node* next;
                  Node* prev;
        };
        class Node
        {
              public:
                  int   data;
                  Node* next;
                  Node* prev;
        };
    private:
        Node*     head;
        Node*     tail;
};

int main()
{
    return 0;
}
```

http://techn.sstu.ru/kafedri/подразделения/1/MetMat/murashev/oop/lec/lec4.htm

***

## Вопрос 10

**Статические и нестатические атрибуты и методы класса: различия и возможности.**

**Ответ:** 

### СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ АТРИБУТЫ КЛАССА.

Переменные — члены класса можно объявлять как статические (`static`). Они размещаются в специально отведенной области памяти статических переменных(`.data` и `.bss`, смотри [картинку](https://habrastorage.org/r/w1560/webt/6q/ot/dy/6qotdycmpyabn9p0qwtvpkjd7-q.jpeg)). Обычные же (автоматические) данные объектов размещаются в стеке или во временной памяти в зависимости от способа формирования объекта.

Статический компонент можно объявлять не во всяком классе; в частности, в локальных классах, безымянных классах и классах, вложенных в них, не может быть статических компонент.

[//]: <> (//////////////////////////////////////////)
[//]: <> (что такое локальный класс)
[//]: <> (что такое безымянный класс)
[//]: <> (//////////////////////////////////////////)

Если вы объявляете переменную статической, то может существовать только один экземпляр — независимо от того, сколько объектов данного класса создается. Каждый объект просто использует (совместно с другими) эту одну переменную. Запомните, **для обычных (нестатистических) переменных-членов при создании каждого объекта создается новый экземпляр, и доступ к каждому экземпляру возможен только через этот объект. А статическая переменная — только одна, и все объекты класса используют её совместно**.

Кроме этого, одна и та же статическая переменная будет использоваться всеми классами, производными от класса, в котором эта статическая переменная содержится. 

При объявлении статического атрибута необходимо обеспечить для него глобальное определение вне класса. Это необходимо для того, чтобы под статический атрибут была выделена память, причём только один раз. Это делается путем нового объявления статической переменной, причем используется оператор области видимости для того, чтобы идентифицировать тот класс, к которому принадлежит переменная.

Основной смысл поддержки в C++ статических переменных-членов состоит в том, что благодаря им отпадает необходимость в использовании глобальных переменных. Как можно предположить, если при работе с классами задавать глобальные переменные, то это почти всегда нарушает принцип инкапсуляции, являющийся фундаментальным принципом ООП и C++.

***Пример подсчёта созданных экземпляров, используя статистическую переменную (Петрусевич может это спросить!!)***
```c++ 
class A { 
     static int counter;
     int my_number;
public:
     A() { counter++; my_number = counter; }     
     int get_number() const { return my_number; }
};
int A::counter = 0;
int static_counter_of_instances()
{
     A a, b, c, d, e;
     A x[10];
     cout << "a number " << a.get_number() << endl;
     cout << "b number " << b.get_number() << endl;
     cout << "c number " << c.get_number() << endl;
     cout << "d number " << d.get_number() << endl;
     cout << "e number " << e.get_number() << endl;
     for (int i = 0; i < 10; i++)
          cout << "x[" << i << "] number " << x[i].get_number() << endl;
     return 0;
}
```        
Поскольку статическая переменная — член класса существует ещё до создания объекта этого класса, доступ к ней в программе может быть реализован без всякого объекта:
```c++ 
int main() {
     A::counter = 5;
     // ...
}
```        
**Вопрос на засыпку:** Почему при доступе к `A::counter` из `main()` в последнем случае мы получим ошибку компиляции?

[//]: <> (//////////////////////////////////////////)
[//]: <> (Чтобы программист не задавался таким вопросами :], все разделы должны быть указаны явно. см. рекомендацию 44.)  
[//]: <> (//////////////////////////////////////////)

**Ответ:** Атрибут `counter` описан в защищённой части класса. Для доступа к такой переменной можно передвинуть её в зону `public`, но лучше сделать публичным статический метод для доступа к ней.

Необходимо понимать, что **статические переменные медленнее, чем нестатические переменные**. Для того, чтобы обратиться к статической переменной, требуется сделать несколько дополнительных действий (другой сегмент памяти и проверка инициализации переменной). Чаще всего, быстрее выделить локальную переменную на стеке, чем делать дополнительные действия по использованию статической переменной.

### СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ МЕТОДЫ КЛАССА.

Помимо переменных-членов статическими можно объявлять и функции-члены, но обычно это не делается. Доступ к объявленной статической функции — члену класса возможен только для других статических членов этого класса. У статической функции-члена нет указателя `this`. Статические функции-члены не могут быть виртуальными. Статические функции-члены не могут объявляться с идентификаторами `const` (постоянный) и `volatile` (переменный). И наконец, статические функции — члены класса могут вызываться любым объектом этого класса, а также через имя класса и оператор расширения области видимости без всякой связи с каким бы то ни было объектом этого класса.

Однако статические методы могут оказаться удобными для предварительной опеределения статических атрибутов до создания экземпляров или просто независимо от доступа к ним.

В C++ статические члены класса не инициализируются с помощью конструктора, поскольку они не зависят от инициализации объекта, хотя в некоторых языках программирования есть возможность инициализировать статические поля через статический конструктор. 

***

## Вопрос 11

**Чем отличается статический метод от статического атрибута класса?** 

**Ответ:** 

Статистические атрибуты – это поля, т.е. статистические переменные класса, а методы – это функции. (?, очень странный вопрос)

***

## Вопрос 12

**Есть ли особенности наследования у классов со статическими членами?** 

**Ответ:** 

Очевидно из предыдущих вопросов! Имеется только одна копия статической переменной — члена класса, и все объекты класса используют ее совместно. Кроме этого, **одна и та же статическая переменная будет использоваться всеми классами, производными от класса, в котором эта статическая переменная содержится.**
Пример.
```c++
#include <iostream>
class A {
public:
  A() { std::cout << "Constructor A" << std::endl; }
  ~A() { std::cout << "Destructor A" << std::endl; }
};
class B {
public:
  B() { std::cout << "Constructor B" << count++ << std::endl; }
  ~B() { std::cout << "Destructor B" << --count << std::endl; }
private:
  static A a; // объявление
  static int count; // объявление
};
A B::a; // определение
int B::count = 1; // определение
int main() {
  B b1, b2, b3;
  return 0;
}
```

Вывод:
     
     Constructor A
     Constructor B1
     Constructor B2
     Constructor B3
     Destructor B3
     Destructor B2
     Destructor B1
     Destructor A 
***

## Вопрос 13

**Константные и неконстантные параметры метода. Константный метод: назначение, оформление.**

**Ответ:**

Сперва сделаем краткий обзор на константные и неконстантные параметры функции. 

Параметры могут быть константными - значения таких параметров не могут меняться. Константному параметру можно передать в качестве аргумента как константу, так и переменную:
```c++ 
#include <iostream>
void square(const int, const int);
int main()
{
     const int a = 4;
     int b = 5;
     square(a, b);   // 20
     return 0;
}
void square(const int a, const int b)
{
     //a = a * a;     так нельзя сделать
     //b = b * b;     так нельзя сделать
     std::cout << "In square: a * b = " << a * b << std::endl;
}
```        

[//]: <> (//////////////////////////////////////////)
[//]: <> (передавать в фунукцию констанстный параметр можно только по константной ссылке. Потому что в результате передачи по ссылке мы не копируем объект[+оптимизаци], а константность ссылки даёт неизменяемость параметра.)
[//]: <> (//////////////////////////////////////////)

От этой ситуации следует отличать передачу констант в качестве аргументов для неконстантных параметров:
```c++ 
#include <iostream>
void square(int, int);
int main()
{
     const int a = 4;
     const int b = 5;
     square(a, b);   // 400
     return 0;
}
void square(int a, int b)
{
     a = a * a;
     b = b * b;
     std::cout << "In square: a * b = " << a * b << std::endl;
}
```    

[//]: <> (//////////////////////////////////////////)
[//]: <> (Зачем разделять объявление функции `square` c её определением, я думаю, что здесь это лишее)
[//]: <> (//////////////////////////////////////////)

Несмотря на то, что при вызове функции ей передаются константы, но так как сами параметры не являются константными, то функция может изменять их значения. (Поскольку при передаче их в функцию происходит их копирование, дальше функция работает с их копиями) Обзор закончен, переходим к важным вещам!1!!!

Функции — члены класса могут объявляться постоянными (с идентификатором `const`). **Если функция объявлена постоянной, она не может изменить вызывающий ее объект**. Кроме этого, постоянный объект не может вызвать непостоянную функцию-член. Тем не менее, постоянная функция-член может вызываться как постоянными, так и непостоянными объектами.

Обратите внимание, что ключевое слово `const` указывают следом за списком параметров функции, а не перед именем функции:
```c++ 
class X {
     int some_var;
public:
     int fl() const; // постоянная функция-член
};
```
Для примера рассмотрим следующую программу.
```c++ 
#include <iostream>
using namespace std;
class Demo {
     int i;
public:
     int geti () const {
          return i; // здесь все правильно
     }
     void seti (int x) const {
          i = x; // Ошибка!!!
     }
};
    
int main() {
     Demo ob;
     ob.seti(1900) ;
     cout << ob.geti();
     return 0;
}
```
Данная программа выдаст ошибку на этапе компиляции, поскольку функция-член `seti()` объявлена постоянной, что означает невозможность изменения вызывающего ее объекта. Таким образом, попытка изменения функцией переменной i ведет к ошибке. С другой стороны, поскольку функция `geti()` не меняет переменной i, она совершенно правильна.

Возможна ситуация, когда вам понадобится, чтобы функция-член, оставаясь постоянной, тем не менее была способна изменить один или несколько членов класса(например, [кеширование!](https://habr.com/ru/company/infopulse/blog/341264/)). Это достигается заданием модифицируемых членов класса (ключевое слово `mutable`). **Модифицируемый член класса можно изменить с помощью постоянной функции-члена.**
```c++ 
#include <iostream>
using namespace std;
    
class Demo {
          mutable int i;
          int j ;
     public:
          int geti() const {
               return i; // здесь все правильно
          }
        
          void seti(int x) const {
               i = x; // теперь все правильно
          }
        
          void setj (int x) const {
               j = x; // здесь прежняя ошибка
          }
};
    
int main()
{
     Demo ob;
     ob.seti(1900) ;
     cout << ob.geti () ;
     return 0;
}
```
Здесь переменная i задана модифицируемой, поэтому ее может изменить функция-член `seti()`. Тем не менее, поскольку переменная j по-прежнему остается не модифицируемой, постоянная функция-член `setj()` не может изменить ее значение.

***

## Вопрос 14

**Могут ли одноимённые методы с одинаковыми параметрами различаться лишь константностью по одному из параметров?**

**Ответ:**

Объявления параметров, которые отличаются только наличием или отсутствием `const` и / или `volatile` эквивалентны. Ошибка во время компиляции, поскольку воспринимает их за один и тот же метод.

А вот перегрузить функцию таким образом, чтобы получить константную и неконстантную версии одной и той же функции, возможно. Это работает, потому что квалификатор `const` считается частью сигнатуры функции, поэтому две функции, которые отличаются только своей константностью, считаются разными.

[//]: <> (//////////////////////////////////////////)
[//]: <Сигнатура?> (Что такое сигнатура функции?)
[//]: <volatile?> (Зачем это нужно?)
[//]: <> (//////////////////////////////////////////)

***

## Вопрос 15

**Предопределённый указатель this. Назначение, использование и предосторожности.**

**Ответ:** 

C++ содержит специальный указатель `this`. Это указатель, который **автоматически передается любой функции-члену при ее вызове и указывает на объект, генерирующий вызов**. Явно объявить, инициализировать либо изменить указатель `this`, возможности нет. Поскольку указатель неизменяем, назначения указателю this запрещены.

Важно понимать, что указатель **`this` передается только функциям-членам**. Дружественным функциям указатель `this` не передается.

Указатель объекта `this` не является частью самого объекта. Он не отражается в результате `sizeof` оператора для объекта. Если для объекта вызывается нестатическая функция-член, **компилятор передает адрес объекта функции в качестве скрытого аргумента**. Например, вызов следующей функции
```c++ 
myDate.setMonth(3);
```    
можно интерпретировать следующим образом:
```c++ 
setMonth(&myDate, 3);
```
Использовать указатель `this` можно по-разному. Он **особенно полезен при перегрузке операторов**. 

Выражение `*this` обычно **используется для возврата текущего объекта из функции-члена**:
```c++ 
return *this;
```    
Указатель `this` также **используется для защиты от самосохраняющей ссылки**:
```c++ 
if (&Object != this) {
// do not execute in cases of self-reference
}
```
A так выглядел бы код, если бы мы всегда прописывали все через указатель `this` (так дейтсвительно можно писать, но это не имеет смысла):
```c++ 
#include <iostream>
#include <cstring>
using namespace std;
        
class inventory {
     char item[20];
     double cost;
     int on_hand;
public:
     inventory (char *i, double c, int o)
     {
          strcpy (this->item, i) ; // доступ к члену
          this->cost = с; // через
          this->on_hand = о; // указатель this
     }
     void show {};
};
        
void inventory::show()
{
     cout << this->item; // использование this для доступа к членам
     cout << ": $" << this->cost;
     cout << " On hand: " << this->on_hand << "\n";
}
```
***

## Вопрос 16

**Можно ли указатель this передать не методу класса, а во внешнюю функцию?**

* Нет, this относится к текущему экземпляру класса и поэтому может использоваться только в методах экземпляра.

* Указатель this — это указатель, доступный только в нестатических функциях-членах classstructтипа или union типа. Он указывает на объект, для которого вызывается функция-член. Статические функции-члены не имеют указателя this .

***

## Вопрос 17

**Что делать, если часть начинки двух классов должна совпадать, а классы "не должны догадываться" друг о друге?**									

Я нашла два варианта решения данной задачи и для каждого приведу пример (но все же думаю, Петрусевич хотел бы услышать от нас первый вариант).

1. С помощью абстрактного класса
```cpp
#include <iostream>
using namespace std;
 
// Родительский класс
class Shape {
   public:
      // виртуальные функции в какой-то мере аналог интерфейсов, а по сути в этой задачи мы хотим реализовать интерфейс
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Производные классы
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};
class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout << "Total Rectangle area: " << Rect.getArea() << endl;
   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout << "Total Triangle area: " << Tri.getArea() << endl; 
   return 0;
}
```

2. С помощью шаблона (strategy pattern)
```cpp
template <class SpecificStrategy>
class A {
 private:
    double data;
 public:
    double calc(){
       return data*data;
    }
    double especific() {
       return SpecificStrategy::especific(data);
    }
};
class DoubleStrategy {
   static double especific(double data) {
      return 2 * data;
   }
};
class TripleStrategy {
   static double especific(double data) {
      return 3 * data;
   }
};
int main(){
    A<DoubleStrategy> x;
    A<TripleStrategy> y;
}
```

## Вопрос 18

**Дружественные функции: назначение и отличия от методов класса. Понятие дружественного класса.** 

**Ответ:**

Возможны ситуации, когда для получения доступа к закрытым членам класса вам понадобится функция, не являющаяся членом этого класса. Для достижения этой цели в C++ поддерживаются дружественные функции (`friend functions`). **Дружественные функции не являются членами класса, но тем не менее имеют доступ к его закрытым элементам**.

Дружественная функция задается так же, как обычная, не являющаяся членом класса, функция. Однако в объявление класса, для которого функция будет дружественной, необходимо включить ее прототип, перед которым ставится ключевое слово `friend`. В пользу существования дружественных функций имеются несколько доводов, связанных с **перегрузкой операторов и созданием специальных функций ввода/вывода, а так же функций, которые имели бы доступ к закрытым членам двух или более разных классов**.

Чтобы понять, как работает дружественная функция, рассмотрим следующую короткую программу:
```c++ 
#include <iostream>
using namespace std;
    
class myclass {
          int n, d;
     public:
          myclass (int i, int j) { n = i; d = j; }
          // объявление дружественной функции для класса myclass
          friend int isfactor(myclass ob);
};
int isfactor(myclass ob)
{
     if(!(ob.n % ob.d)) return 1;
     else return 0;
}
```    
В этом примере в объявлении класса `myclass` объявляются конструктор и дружественная функция `isfactor()`. Поскольку функция `isfactor()` дружественна для класса `myclass`, то функция `isfactor()` имеет доступ к его закрытой части. Поэтому внутри функции `isfactor()` можно непосредственно ссылаться на объекты ob.n и ob.d.

Важно понимать, что дружественная функция не является членом класса, для которого она дружественна. Поэтому **невозможно вызвать дружественную функцию, используя имя объекта и оператор доступа к члену класса (точку или стрелку)**. Например, по отношению к предыдущему примеру ЭТА ИНСТРУКЦИЯ НЕПРАВИЛЬНА:
```c++ 
obi.isfactor(); // неправильно, isf actor () — это не функция-член
isfactor(obi); // правильно
```    
Хотя дружественная функция "знает" о закрытых элементах класса, для которого она является дружественной, доступ к ним она может получить только через объект этого класса. Таким образом, **в отличие от функции-члена `myclass`, в котором можно непосредственно упоминать переменные `n` и `d`, дружественная функция может иметь доступ к этим переменным только через объект, который объявлен внутри функции или передан ей**.

**Класс `friend` — это класс, все функций-члены которого являются дружественными функциями класса**, то есть функции-члены которого имеют доступ к закрытым и защищенным членам другого класса.  Дружественный класс имеет доступ ко всем переменным/функциям исходного класса. Объявляется он так же, как и дружественная функция, с помощью ключевого слова `friend`.

Несколько дополнительных замечаний о дружественных классах. Во-первых, **дружественный класс не имеет прямого доступа к указателю `*this` объектов исходного класса**. Во-вторых, **дружественные отношения не являются взаимными** (сл. вопрос). Если вы хотите, чтобы два класса дружили друг с другом, они оба должны объявить друг друга друзьями. Наконец, если класс A является другом B, а B – другом C, это не означает, что A является другом C.

Будьте осторожны при использовании дружественных функций и классов, потому что это позволяет дружественной функции или классу нарушать инкапсуляцию. Если детали реализации класса изменятся, то детали реализации друга также должны будут быть изменены. Следовательно, ограничьте использование дружественных функций и классов до минимума.

***

## Вопрос 19

**Может ли класс A быть другом класса B, а обратное не справедливо?** 

**Ответ:**

Да. **Дружественные отношения не являются взаимными, если это не указано явным образом.**  

Если A – друг B, то В – не друг А, пока Вы не укажете это явно. Если A – друг B, В – друг С, то А и С не друзья, пока Вы не укажете это явно.

***

## Вопрос 20

**Дружественные базовому классу функции и их использование из порождённых классов.** 

**Ответ:** 

~~**Дружественные отношения не наследуются**. Поэтому если в базовый класс включается дружественная функция, то эта дружественная функция не является таковой для производных классов. Поскольку дружественная функция принимает ссылку на объект класса или сам объект, чтобы вызвать друга родителя, имея объект класса потомка, **нужно преобразование к типу родителя**.~~

Я всех обманула))) Смотрите:
```c++
#include <iostream>
using namespace std;
class A
{
public:
	int a;
	A() { a = 0; }
	A(int g) { a = g; }
	friend void geta(A d);
};
void geta(A d) { cout << "a = " << d.a << '\n'; }
class B : public A 
{
public:
	int b;
	B() { b = 2; }
	B(int s) { b = s; }
};
int main()
{
	A a(3);
	B b(4);
	geta(a);
	geta(b);
}
```
Вывод:
```c++
a = 3
a = 0
```
В чем суть? Дружественные отношения и правда не наследуются, дружественная функция родительского класса действительно не является таковой для производных классов, но мы не забываем, что при создании объекта класса-наследника неявно создается объект класса-родителя. И когда мы в дружественнную для базового класса функцию передаем объект производного типа, эта дружественная функция работает именно с ядром - объектом базового класса внутри производного, который был создан конструктором по умолчанию. Такие дела


[//]: <> (//////////////////////////////////////////)
[//]: <> (это не так, поэксперементируй)
[//]: <> (преобразование к типу родителя, кажется, невозможно)
[//]: <> (//////////////////////////////////////////)
***

## Вопрос 21

**Может ли одна функция быть дружественной нескольким классам одновременно?**

**Ответ:** 

Функцию **можно объявить дружественно сразу нескольким классам**. Для этого описание класса надо разбить на две части (в момент задания прототипа дружественной 
функции в первом классе должна быть информация существовании второго класса).
```c++ 
class truck; // предварительное объявление
    
class car {
     int passengers;
     int speed;
public:
     car(int p, int s) { passengers = p; speed = s; }
     friend int sp_greater (car c, truck t) ;
};
    
class truck {
     int weight;
     int speed;
public:
     truck(int w, int s) { weight = w; speed = s; }
     friend int sp_greater (car c, truck t) ;
};
    
int sp_greater (car c, truck t) { return с. speed — t. speed; }
```

[//]: <> (//////////////////////////////////////////)
[//]: <> (для производного класса дружественная функция родительского тоже будет дружественной)
[//]: <> (//////////////////////////////////////////)

В этой программе имеется функция `sp_greater()`, которая дружественна для классов `саг` и `truck`. 

Эта программа иллюстрирует один важный элемент синтаксиса C++ — **предварительное объявление** (`forward declaration`), которое еще называют **ссылкой
вперед** (`forward reference`). Поскольку функция `sp_greater()` получает параметры обоих классов `саг` и `truck`, то логически невозможно объявить и тот и другой
класс перед включением функции `sp_greater()` в каждый из них. Поэтому необходим иной способ сообщить компилятору имя класса без его фактического объявления. Этот способ и называется предварительным объявлением. В C++, чтобы информировать компилятор о том, что данный идентификатор является именем класса, перед первым использованием имени класса вставляют следующую строку:
```c++ 
class имя_класса; 
```
***

## Вопрос 22

**Может ли метод одного класса быть другом другого класса?**

**Ответ:**

**Да**. Сделаем метод класса А дружественной функцией для В. О классе B должно быть известно перед заданием класса А.
```c++ 
class B;
   
class A {
private:
     int x;
public:
     A() { x = 1; }
     void print() { cout << x; }
     void f(B b);
};
    
class B {  
private:
     int y;
public:
     B() { y = 5; }
     friend void A::f(B b);
};
    
void A::f(B b) { x = b.y; }
```
***

## Вопрос 23

**Перегрузка функций: назначение и правила. Проиллюстрируйте простыми примерами допустимых и недопустимых вариантов перегрузки.**

**Ответ:** 

**Перегрузка функций** – это возможность использовать одно имя функции для множества различных действий. Это означает, что **можно создать общий интерфейс для группы близких по смыслу действий**. Т.е. перегруженные функции позволяют упростить программы, допуская обращение к одному имени для выполнения близких по смыслу действий. В C++ две или более функции могут **иметь одно и то же имя, отличаясь либо возвращаемым типом данных, либо числом своих аргументов, либо и тем и другим**.

Перегрузить функцию очень легко: просто объявите и определите все требуемые варианты. Компилятор автоматически выберет правильный вариант вызова на основании числа и/или типа используемых в функции аргументов.

**ПРИМЕРЫ**

1. Для языка С, в котором полиморфизм поддерживается недостаточно, нахождение абсолютной величины числа требует трех различных функций: `abs()`, `labs()` и `fabs()`. Эти функции подсчитывают и возвращают абсолютную величину целых, длинных целых и чисел с плавающей точкой соответственно. В C++ каждая из этих функций может быть названа `abs()`. Так выглядит реализация этого:
```c++ 
#include <iostream>
using namespace std;
// Перегрузка abs() тремя способами
int abs(int n);
long abs(long n);
double abs(double n);
int main() {
     cout << "Абсолютная величина -10:" << abs(-10) << "\n/n";
     cout << "Абсолютная величина -10L:" << abs (-10L) << "\n/n";
     cout << "Абсолютная величина -10.01:" << abs (-10. 01) << "\n/n";
     return 0;
}
// abs() для целых
int abs (int n) {
     cout << "В целом abs()\n";
     return n < 0 ? -n: n;
}
// abs() для длинных целых
long abs (long n) {
     cout << "В длинном целом abs()\n";
     return n < 0 ? -n: n;
}
// abs() для вещественных двойной точности
double abs (double n) {
     cout << "В вещественном abs() двойной точности \n";
     return n < 0 ? -n: n;
}
```

[//]: <> (//////////////////////////////////////////)
[//]: <long> (сейчас нет разницы между `int` и `long` они полностью эквиваленты, код ниже показывает это. Это работает для x86 и x64 )
[//]: <> (//////////////////////////////////////////)

```c++
#include <iostream>
#include <limits>
int main()
{
	long x = 1;
	std::cout << sizeof(x) << " : ";
	std::cout << std::numeric_limits<long>::max() << " : ";
	std::cout << std::numeric_limits<long>::min();
	int n = 1;
	std::cout << '\n' << sizeof(n) << " : ";
	std::cout << std::numeric_limits<int>::max() << " : ";
	std::cout << std::numeric_limits<long>::min();
	return 0;
}
```

1. Здесь могли быть кодики с перегрузкой функций, отличающихся типами и/или числом принимаемых параметров, но их не будет, потому что вы умняшки и сами все умеете 

2. ПРИМЕР НЕДОПУСТИМОЙ ПЕРЕГРУЗКИ ФУНКЦИИ. Важно понимать, что **тип возвращаемого значения сам по себе еще не является достаточным отличием для перегрузки функции**. Если две функции отличаются только типом возвращаемых данных, компилятор не всегда сможет выбрать нужную.
                
```c++ 
// Это все неправильно и не будет компилироваться
int fl (int a) {};
double fl (int а) {};
...         
f1 (10); // какую функцию выбрать компилятору???         
```

[//]: <> (//////////////////////////////////////////)
[//]: <> (что тогда ещё нужно?)
[//]: <> (//////////////////////////////////////////)

***

## Вопрос №24.

### Что будет, если в классе перегружена функция, внешняя по отношению к классу?

В классе нельзя перегрузить внешнюю функцию... :sweat_smile:

***

## Вопрос 25

**Перегрузка операций: основные правила и ограничения. Выбор реализации между чисто внешними, дружественными функциями и методами класса.**

Самое главное, что необходимо помнить — перегрузка операторов, это всего лишь более удобный способ вызова функций, поэтому не стоит увлекаться перегрузкой операторов. Использовать её следует только тогда, когда это упростит написание кода. Необходимо учитывать приоритет и ассоциативность операторов, они при перегрузке не меняются и должны соответствовать ожиданиям пользователя.

## Синтаксис перегрузки
Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>). Рассмотрим простейший пример:
```cpp
class Integer
{
private:
    int value;
public:
    Integer(int i): value(i) 
    {}
    const Integer operator+(const Integer& rv) const {
        return (value + rv.value);
    }
};
```
В данном случае, оператор оформлен как член класса, аргумент определяет значение, находящееся в правой части оператора. Вообще, существует три основных способа перегрузки операторов: глобальные функции, дружественные для класса, или методы самого класса.
Роб Мюррей, в своей книге C++ Strategies and Tactics определил следующие рекомендации по выбору формы оператора:
| Оператор                        | Рекомендуемая форма     |
| ------------------------------- | ----------------------- |
| Все унарные операторы           | Член класса             |
| = () [] -> ->*                  | Обязательно член класса |
| += -= /= *= ^= &= |= %= >>= <<= | Член класса             |
| Остальные бинарные операторы    | Не член класса          |

***

## Вопрос 26

**Может ли одна и та же операция в одном и том же классе быть перегруженной разными способами?** 

**Ответ:** 

Один и тот же оператор **можно перегрузить несколько раз**. Для унарных операторов может быть всего два варианта — с квалификатором `const` и без него (для функций-членов), или варианты с параметром типа константная ссылка или обычная ссылка (для свободных функций). Для бинарных операторов и оператора () количество перегрузок не ограничено.

***


## Вопрос 28
**Перегрузка операции () и понятие функтора.**

```c++
#include <iostream>
using namespace std;

//Вопрос 28

//Перегрузка операции () и понятие функтора.

// функтор - это класс у которого переопределён опертор "()"
// переопределив этот оператор мы получаем объект класса который может вести себя как функция
// пример приведён в main
// пример функтора - класс functor
// про функтор подробнее можно почитать тут "https://purecodecpp.com/archives/3448"

class functor
{	
	public:
		int mod = 7;

		int operator() (int a, int b)
		{	
			int sum = a + b;
			// тут приведён простой пример харнения данных с помощью функтора
			// он запоминает количество использований данной "функции"
			counterSumm++;
			cout << endl;
			return sum % mod;
		}

		void howSumm()
		{
			cout <<endl << "howsumm =" << counterSumm << endl;
		}

	private:
		int counterSumm = 0;
};

int main()
{
	functor t;
	t.howSumm();
	cout << t(5, 5);
	cout << t(6, 15);
	t.howSumm();
	cout << t(1, 1);
	cout << t(7, 0);
	cout << t(7, 7);
	t.howSumm();
	return 0;
}
```

## Вопрос 30

**Перегрузка операции индексирования [], её константный и неконстантный варианты. Обобщение индекса и многомерные массивы.**

```c++
#include <iostream>
using namespace std;

//Вопрос 30

//Перегрузка операции индексирования []
//её константный и неконстантный варианты. Обобщение индекса и многомерные массивы.

//Перегрузка операции индексирования [] приведена в классе test
class test
{	
	public:
		
		//константный
		int & operator[](int i)
		{
			return arr[i];
		}

		//неконстантный
		const int & operator[] (int i) const
		{
			return arr[i];
		}

		//обобщение индекса (таким мы занимались в приктической по ООП номер 5 в классе BaseMatrix)
		int operator()(int i, int j)
		{
			return mass[i][j];
		}

		int print()
		{
			for (int i = 0; i < 5; i++)
				cout << arr[i] << " ";
			cout << endl;
			return 0;
		}

	private:
		int arr[5]{5,44,4,987,69};

		int mass[3][5] = {
							{ 1, 2, 3, 4, 5 },
							{ 2, 4, 6, 8, 10 },
							{ 3, 6, 9, 12, 15 }
						};
};

int main()
{
	test p;
	cout << p[2] << endl;
	p.print();
	p[2] = 1111;
	p.print();
	cout << p[2] << endl;

	cout << "//////////////////////////" << endl;
	const test cp;
	cout << cp[3] << endl;
	//т.к. объект cp константый - скомпилировать следующую строку нельзя
	//cp[3] = 5051;

	cout << "//////////////////////////" << endl;
	test y;
	cout << y(2,3) << endl;
}
```

***

## Вопрос 31
**Перегрузка операций << и >> и введение в класс собственных инструментов ввода/вывода.**
```c++
#include <iostream>
#include <string>
#include <fstream>
using namespace std;

//Вопрос 31

//Перегрузка операций << и >> и введение в класс собственных инструментов ввода/вывода.

//введение в класс собственных инструментов ввода / вывода приведено в main
class test
{
	public:
		
//делать их дружественными не обязательно если поля в public, но т.к. обычно поля в прогах находятся в private, то надо )
		friend ostream& operator<<(ostream& os, const test& t);
		friend istream& operator>> (istream& is, test& t);

		test()
		{
			x = y = z = 0;
		}

		test( int X, int Y, int Z)
		{
 x = X;
 y = Y;
 z = Z;
		}

 private:
 int x;
 int y;
 int z;
};

// Перегрузка операций << и >>
// обязательно для этого нужно #include <fstream>
ostream& operator<<(ostream& os, const test& t)
{	
 os << t.x << " " << t.y << " " << t.z;
 return os;
}

istream& operator>> (istream& is, test& t)
{
 is >> t.x >> t.y >> t.z;
 return is;
}

int main()
{	
 //необязательная вещь в данном примере (оставил для себя)
 //setlocale(LC_ALL, "ru");

 test p(1, 2, 3);
 cout << p << endl;

////////////////////////////////////ВВОД//////////////////////////////////////////////////////
 //название файла
 string path = "myFile.txt";
 //создаём поток
 fstream fs;
 //открываем файл с названием, есл и его нет, то open его же и создаёт
 fs.open(path);

 //проверяем открыт ли файл 
 if (fs.is_open())
	{
 //записываем в файл нашу "p" с помощью ранее переопределённых "<<"
 fs << p << endl;
	}

 //закрываем файл, чтобы каретка сдвинулась в начало файла при дальнейшем открытии
 //если это не сделать, то при чтении из файла считаются пустые элементы (конец файла)
 fs.close();

 //fs.seekg(0); есть команда "seekg" для возврата каретки, но я сделал как сделал )

	

////////////////////////////////////ВЫВОД//////////////////////////////////////////////////////
 test pp;
 cout << "/////" << endl;
 cout << pp << endl;
 //снова открываем файл с названием
 fs.open(path);
 //считываем оттуда данные в "pp"
 fs >> pp;
 fs.close();
//////////////////////////////////////////////////////////////////////////////////////////////

 cout << "/////" << endl;
 cout << pp << endl;

}
```

***

## Вопрос 32
**Что и как нужно сделать, чтобы мочь выводить содержимое объекта некоторого класса на экран?**
Можно переопределить стандартный оператор сдвига `<<`.

***

## Вопрос 34

**Перегрузка одноместных операций -, * и &. Зачем она нужна?**

Перегрузка унарного минуса нужна для изменения знака числа.

**Унарный оператор `*`**

Этот унарный оператор часто перегружают в паре с оператором `->`. Как правило, он возвращает ссылку на элемент, указатель на который возвращает оператор `->`. Этот оператор обычно реализуется как константная функция-член.
В стандартной библиотеке оператор `*` перегружен для интеллектуальных указателей и итераторов.
Аналогично с опратором `&`.

***


# Вопрос 35
**Как автоматически обнаруживать потери динамической памяти?**

_Утечка памяти происходит, когда динамическая память, которая уже
использована в программе и далее не нужна, не освобождается._ 

Утечки – существенная проблема для процессов, которые должны работать в системе долго (и требуют памяти в течение длительного времени). 

* Оперативная память (ОЗУ) —  память, часть системы
памяти ЭВМ, в которую процессор может обратиться за одну
операцию. Предназначена для временного хранения данных и
команд, необходимых процессору для выполнения им операций.
Оперативная память передает процессору данные
непосредственно, либо через кеш-память.

* Каждая ячейка оперативной памяти имеет свой
индивидуальный адрес

* Динамическое выделение памяти может происходить, например, в конструкторе копий, после выхода из этого конструктора память очищена не будет - деструктор не сработает

* Следует выделять и освобождать память в одном и том же модуле.


# Автоматический поиск утечки

Существует методика нахождения утечек при помощи библиотеки **CRT** 
```c++
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
```

* Оператор #define сопоставляет базовые версии функций кучи CRT соответствующим отладочным версиям. Если оператор #define не используется, дамп утечки памяти будет менее подробным.

* Включение файла crtdbg.h сопоставляет функции malloc и free с их отладочными версиями, _malloc_dbg и _free_dbg, которые отслеживают выделение и освобождение памяти. Это сопоставление используется только в отладочных построениях, в которых определен _DEBUG. В окончательных построениях используются первоначальные функции malloc и free .

* После того как с помощью этих операторов будут включены отладочные функции кучи, можно поместить вызов _CrtDumpMemoryLeaks перед точкой выхода приложения для отображения отчета об утечке памяти перед завершением работы приложения.
``` c++
_CrtDumpMemoryLeaks();
```
* Если приложение имеет несколько выходов, вам не нужно вручную размещать _CrtDumpMemoryLeaks в каждой точке выхода. Для автоматического вызова _CrtDumpMemoryLeaks в каждой точке выхода поместите вызов _CrtSetDbgFlag в начале приложения с помощью следующих битовых полей:
  
``` c++
_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
```
* По умолчанию _CrtDumpMemoryLeaks выводит отчет об утечке памяти в область Отладка окна Вывод . Если используется библиотека, она может переустановить вывод в другое расположение.

* _CrtSetReportMode можно использовать для перенаправления отчета в другое расположение или обратно в окно вывода, как показано ниже:

```c++
_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_DEBUG );
```

# Интерпретация отчета об утечке памяти

* Если приложение не определяет _CRTDBG_MAP_ALLOC, _CrtDumpMemoryLeaks отображает отчет об утечке памяти, аналогичный следующему:

```cmd
Detected memory leaks!
Dumping objects ->
{18} normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```
* Если приложение определяет _CRTDBG_MAP_ALLOC, отчет об утечке памяти выглядит следующим образом:

```cmd
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\leaktest\leaktest.cpp(20) : {18}
normal block at 0x00780E80, 64 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
Object dump complete.
```

* Во втором отчете отображается имя файла и номер строки, в которой впервые было произведено выделение утекающей памяти.

**Общий вид вывода сообщения об ошибке:**

* Номер выделения памяти, в этом примере — 18.
* Тип блока, в примере — normal.
* Расположение памяти в шестнадцатеричном формате, в этом примере — 0x00780E80.
* Размер блока, в этом примере — 64 bytes.
* Первые 16 байт данных в блоке, в шестнадцатеричном формате.

# Примечания:

* Блок CRT — это блок памяти, выделенной библиотекой CRT для внутреннего использования. Библиотека CRT обрабатывает освобождение этих блоков, поэтому CRT-блоки не будут отображаться в отчете об утечке памяти, если нет серьезных проблем с библиотекой CRT.
* Предыдущие способы выявляют утечки памяти для памяти, выделенной с помощью стандартной функции malloc библиотеки CRT. Однако если программа выделяет память с использованием оператора new C++, то в отчете об утечке памяти вы увидите только имя файла и номер строки, где operator new вызывает _malloc_dbg. 
* Чтобы создать более полезный отчет об утечке памяти, можно написать макрос следующего вида, и в отчете будет указываться строка, в которой было выполнено выделение:

```c++
#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif
```

Теперь можно заменить оператор new с помощью макроса DBG_NEW в коде. 
В отладочных сборках **DBG_NEW** использует перегрузку глобальных operator **new**, которая принимает дополнительные параметры для типа блока, файла и номера строки. 
Перегрузка **new** вызывает **_malloc_dbg** для записи дополнительных сведений. Отчеты об утечке памяти показывают имя файла и номер строки, в которой были выделены утечки объектов. Сборки выпуска по-прежнему используют **new** по умолчанию. 
Вот пример этого метода:

```c++
// debug_new.cpp
// compile by using: cl /EHsc /W4 /D_DEBUG /MDd debug_new.cpp
#define _CRTDBG_MAP_ALLOC
#include <cstdlib>
#include <crtdbg.h>

#ifdef _DEBUG
    #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    // Replace _NORMAL_BLOCK with _CLIENT_BLOCK if you want the
    // allocations to be of _CLIENT_BLOCK type
#else
    #define DBG_NEW new
#endif

struct Pod {
    int x;
};

void main() {
    Pod* pPod = DBG_NEW Pod;
    pPod = DBG_NEW Pod; // Oops, leaked the original pPod!
    delete pPod;

    _CrtDumpMemoryLeaks();
}
```
```cmd
Detected memory leaks!
Dumping objects ->
c:\users\username\documents\projects\debug_new\debug_new.cpp(20) : {75}
 normal block at 0x0098B8C8, 4 bytes long.
 Data: <    > CD CD CD CD
Object dump complete.
```

***

## Вопрос 36

**Перегрузка new и delete. Различие скалярной и векторной форм.**

**Ответ:**

Оператор `new` нужно перегружать в случаях, если **память выделяется по-особому (нестандартным способом)**. Соответственно, оператор `delete` должен освобождать эту память нестандартным способом. Как правило, **если в классе перегружается оператор `new`, то в этом классе также перегружается оператор `delete`**.

Операторы `new` и `delete` **могут быть перегружены двумя способами**. Эти способы отличаются объявлением операторной функции:

- перегрузка операторов `new` и `delete` с помощью операторной функции, которая реализована в пределах класса. Это есть способ перегрузки `new` и `delete` для конкретного класса. При вызове `new` и `delete` для этого класса будут вызваны перегруженные операторные функции, которые выделяют/освобождают память специфическим образом. При вызове операторов `new` и `delete` для других классов используются глобальные операторы `new` и `delete`;

- глобальная перегрузка операторов `new` и `delete`. В этом случае операторы `new` и `delete` перегружаются для встроенных типов (`float`, `int` и т.д.).

**Общая форма перегрузки оператора `new` имеет следующий вид:** 
```c++
return_type* operator new  ( std::size_t count ) {...};
return_type* operator new[] ( std::size_t count ) {...};
```

в которой

- `return_type` – тип (класс), на который операторная функция возвращает указатель, для которого выделена память по особому (нестандартным способом). Зачастую здесь используют **указатель на пустоту `void*`**, везде разная инфа;

- `size` – размер памяти, которая выделяется для типа `return_type`. Количество байт выделяемой памяти не обязательно должно совпадать со значением `size`, так как в теле операторной функции память можно выделять по-особому.

**Общая форма перегрузки оператора `delete` имеет следующий вид:**
```c++
void operator delete  ( void* ptr ) noexcept;
void operator delete[] ( void* ptr ) noexcept;
```
в которой `pointer` – указатель на область памяти, которая была предварительно выделена оператором `new`.

Внутри метода `operator new()` для выделения памяти обычно используется функция `malloc()`, которая работает с памятью на более низком уровне, чем `new`, а для освобождения памяти внутри метода `operator delete()` — функция `free()`. Либо же с помощью оператора разрешения области видимости `::` можно получить доступ к соответствующим стандартным функциям.

**ПРИМЕРЫ**
1. С помощью оператора разрешения области видимости `::` внутри класса:
```c++
class X
{
// ...
public:
    void* operator new(std::size_t size)
    {
        std::cout << "X new\n";
        return ::operator new(size);
    }
    void operator delete(void* ptr)
    {
        std::cout << "X delete\n";
        ::operator delete(ptr);
    }
    void* operator new[](std::size_t size)
    {
        std::cout << "X new[]\n";
        return ::operator new[](size);
    }
    void operator delete[](void* ptr)
    {
        std::cout << "X delete[]\n";
        ::operator delete[](ptr);
    }
};
```


1. С помощью функций `malloc()` и `free()` в виде внешней функции:
```c++
class C {
   ...
   void* operator new(size_t count);
   void operator delete(void *p);
};
void* C::operator new(size_t count) {
   std::cout << "new count=" << count << std::endl;
   void* p = std::malloc(count);   // Выделяем память
   if (!p) throw std::bad_alloc(); // Проверка и генерация исключения
   return p;                       // Возвращаем указатель
}
void C::operator delete(void* p) {
   std::cout << "delete" << std::endl;
   std::free(p);                   // Освобождаем память
}
```

Для **выделения динамических массивов С++ предоставляет векторную форму** операторов `new` и `delete`: `new[]` и `delete[]`. Пример перегрузки векторных форм этих операторов так же приведен выше. 

Когда оператор `new[]` используется для создания массива объектов, то сначала выделяется память для всего массива. Если выделение прошло успешно, то вызывается конструктор по умолчанию (или другой конструктор, если есть инициализатор) для каждого элемента массива начиная с нулевого. Если какой-нибудь конструктор выбрасывает исключение, то для всех созданных элементов массива вызывается деструктор в порядке, обратном вызову конструктора, затем выделенная память освобождается. Для удаления массива надо вызвать оператор `delete[]`, при этом для всех элементов массива вызывается деструктор в порядке, обратном вызову конструктора, затем выделенная память освобождается.

**Внимание!** Необходимо вызывать правильную форму оператора `delete` в зависимости от того, удаляется одиночный объект или массив. Это правило надо соблюдать неукоснительно, иначе можно получить неопределенное поведение, то есть может случиться все, что угодно: утечки памяти, аварийное завершение и т.д. 

***

## Вопрос №37.

### В  чём  различия  обработки  поступившего  указателя  в  `delete` и `delete[]`?

`delete` возвращает память, выделенную оператором `new`, обратно в кучу. Вызов `delete` должен происходить для каждого вызова `new`, чтобы избежать утечки памяти. После вызова `delete` объект, указывающий на этот участок памяти, становится некорректным и не должен больше использоваться (хорошая практика - присвоить указателю `nullptr`).

В чем же отличие `delete` от `delete[]`?
- `delete` - используется, чтобы отменить выделение памяти для отдельных объектов.
- `delete[]` - используется, чтобы отменить выделение памяти для массивов объектов. Вызов `delete[]` для массива объектов приведет к вызову деструктора для каждого объекта перед освобождением памяти, выделенной под массив.

Использование `delete[]` вместо `delete` не всегда ведет к утечке памяти: казалось бы, что должна освободиться память только указателя, но иногда память, выделенная на массив объектов, также освобождается. В любом случае, каждый из них необходимо использовать в определенных выше случаях - иначе, зачастую, результат будет непредсказуем и зависеть от конкретного случая неверного использования.

### Наглядно в коде (взят из [документации](https://docs.microsoft.com/ru-ru/cpp/cpp/delete-operator-cpp?view=msvc-170)):
```cpp
struct UDType
{
};
int main()
{
   // Allocate a user-defined object, UDObject, and an object
   //  of type double on the free store using the
   //  new operator.
   UDType *UDObject = new UDType;
   double *dObject = new double;
   // Delete the two objects.
   delete UDObject;
   delete dObject;
   // Allocate an array of user-defined objects on the
   // free store using the new operator.
   UDType (*UDArr)[7] = new UDType[5][7];
   // Use the array syntax to delete the array of objects.
   delete [] UDArr;
}
```

***

# Вопрос 38
**Перегрузка бинарных операций `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`.**
 
* Бинарные (двухместные) операторы - это такие опреаторы, которые принимают два значения (операнда).

**Рассмотрим operator+ для сложения двух объектов класса Integer:**
Обернём значение int в класс
```c++
class Integer
{
private:
    int value;
public:
    Integer(int i) : value(i) {}

    Integer operator+ (int a)
    {
        return this->value + a;
    }

    friend const Integer operator+ (const Integer& left, const Integer& right);

    friend std::ostream& operator<< (std::ostream& out, const Integer& Int);
    friend std::istream& operator>> (std::istream& in, Integer& Int);
};
```
Вне класса определяем **дружественный** operator+ для сложения объектов класса. В качестве аргументов оператора выступают два значения: левый и правый операнд, желательно передаваемые по константным ссылкам.
```c++
const Integer operator+(const Integer& left, const Integer& right) 
{
    return left.value + right.value;
}
```
```c++
int main()
{
    Integer A(5);
    Integer B(10);
    cout << A + B << "\n";
    cout << A + 5;
}
```

***

# Вопрос 39
**Перегрузка составного присваивания `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `>>=`, `<<=`.**

* **Оператор присваивания** (operator=) используется для копирования значений из одного объекта в другой, уже существующий объект.

* Оператор присваивания работает с уже ранее созданным объектом, т.е. с объектом, который уже ранее был полностью сконструирован (каким-то конструктором). Такой объект уже содержит какие-то корректно помещенные в него осмысленные данные. Задача оператора присваивания - заменить эти старые осмысленные данные новыми осмысленными данными, скопированными из объекта-источника (из правой части оператора присваивания).

* В общем случае, работа оператора присваивания состоит из двух этапов: корректно убрать из объекта старое содержимое, а затем корректно скопировать в него новое содержимое.

* Логика перегрузки оператора присваивания проста за тем исключением, что он должен быть перегружен как **функция-член**.

**Как и в предыдущем примере рассмотрим класс `Integer`.**

```c++
class Integer
{
private:
    int value;
public:
    Integer(int i) : value(i) {}

    Integer operator+ (int a)
    {
        return this->value + a;
    }

    Integer& operator= (int B)
    {
        this->value = B;
        return *this;
    }

    Integer& operator= (const Integer& Int)
    {
        value = Int.value;
        return *this;
    }

    Integer& operator+= (int B)
    {
        this->value = this->value + B;
        return *this;
    }

    Integer& operator+= (const Integer& Int)
    {
        this->value = this->value + Int.value;
        return *this;
    }

    Integer& operator>>= (int B)
    {
        this->value = this->value >> B;
    }

    Integer& operator>>= (const Integer& Int)
    {
        this->value = this->value >> Int.value;
    }

    Integer& operator<<= (int B)
    {
        this->value = this->value << B;
    }

    Integer& operator<<= (const Integer& Int)
    {
        this->value = this->value << Int.value;
    }

    friend const Integer operator+ (const Integer& left, const Integer& right);
    friend std::ostream& operator<< (std::ostream& out, const Integer& Int);
    friend std::istream& operator>> (std::istream& in, Integer& Int);
};

const Integer operator+(const Integer& left, const Integer& right)
{
    return left.value + right.value;
}


std::ostream& operator<< (std::ostream& out, const Integer& Int)
{
    out << Int.value;
    return out;
}
std::istream& operator>> (std::istream& in, Integer& Int)
{
    in >> Int.value;
    return in;
}

int main()
{
    Integer A(5);
    Integer B(10);
    A = 3;
    cout << A << "\n";
    A = B;
    cout << A << "\n";
    A += 3;
    B += A;
    cout << A << ' ' << B;
}
```

***

# Вопрос 40
**Перегрузка операций сравнения `==`, `!=`, `<`, `<=`, `>`, `>=` и её особенности.**

* Следует начать с того, что все операторы сравнения являются **бинарными** операторами, которые не изменяют свои операнды.

* Операторы сравнения перегружают как свободные функции с двумя аргументами. Перегруженный оператор не должен изменять операнды и должен возвращать bool.

Оператор `<`. Свойства: 
* антисимметричность (если x < y равно true, то y < x равно false) 
* транзитивность (если x < y и y < z, то x < z) 
* иррефлексивность (x < x всегда равно false) 
* транзитивная эквивалентность (если !(x < y) && !(y < x) и !(y < z) && !(z < y), то !(x < z) && !(z < x)). 

Оператор `==`. Cвойства: 
* симметричность (если x==y, то y==x) 
* транзитивность ( если x==y и y==z, то x==z) 
* рефлексивность (x==x всегда равно true).

```c++
class Integer
{
private:
    int value;
public:
    Integer(int i) : value(i) {}

    Integer(const Integer& copy) : value(copy.value) {}

    friend bool operator== (const Integer &I_1, const Integer &I_2);
    friend bool operator!= (const Integer &I_1, const Integer &I_2);
};
```
Далее переопределим данные операторы.
```c++
bool operator== (const Integer &I_1, const Integer &I_2)
{
    return (I_1.value == I_2.value);
}
 
bool operator!= (const Integer &I_1, const Integer &I_2)
{
    return !(I_1.value == I_2.value);
}
```

***

# Вопрос 41
**Перегрузка унарный операций `++` и `--`. Различия префиксной и суффиксной форм.**
* Инкремент <=> `++`
* Декремент <=> `--`
* *Рассмотрим перегрузку унарных операторов на данном примере*

```c++
class Integer
{
private:
    int value;
public:
    Integer(int i) : value(i) {}

    //префиксная версия возвращает значение после инкремента
    Integer& operator++() {
        this->value++;
        return *this;
    }

    //постфиксная версия возвращает значение до инкремента
    Integer operator++(int) {
        Integer oldValue(this->value);
        this->value++;
        return oldValue;
    }

    //префиксная версия возвращает значение после декремента
    const Integer& operator--() {
        this->value--;
        return *this;
    }

    //постфиксная версия возвращает значение до декремента
    const Integer operator--(int) {
        Integer oldValue(this->value);
        this->value--;
        return oldValue;
    }
};
```

***Постфиксная* и *префиксная* формы различаются тем, что при выполнении инструкций значение переменной будет изменяться так: для постфиксной формы - *после* выполнения инструкции, для префиксной формы - *до* выполнения инструкции.**

***

# Вопрос 42
**В  каких  случаях  при  перегрузке  операций  создаётся  временный объект?**
* Временный объект — это неименованный объект, созданный компилятором для хранения временного значения. Уничтожается сразу же, как только в нём исчезает потребность.
* Язык Си++ вызывает для них конструкторы (по потребности) и деструкторы (после исполнения выражения).
* При инициализации массивов Си++ временный объект исчезает перед инициализацией следующего элемента.
  
**В некоторых случаях компилятору необходимо создать временные объекты. Такие объекты могут создаваться по следующим причинам:**

* **Чтобы инициализировать ссылку const с инициализатором типа, отличного от базового типа инициализированной ссылки.**
  
    С временным объектом связать лишь константную ссылку. Причем этот временный объект должен быть создан в той же области определения, что и сама ссылка.
    
    ```c++
    friend Matrix & operator+(const Matrix&, const Matrix&);
    ```
    Временный объект создается внутри функции (если это временный объект, а не объект в области динамической памяти), а ссылка определена в области вызова оператора. Поэтому ссылка будет недействительной, в виду разрушения временного объекта по завершении работы функции.

* **Для хранения возвращаемого значения функции, возвращающей определяемый пользователем тип. Эти временные объекты создаются только в том случае, если программа не копирует возвращаемое значение в объект.**

```c++
UDT Func1();    //  Объявление функции, которая возвращает пользовательский тип.
//...
Func1();        //  Вызов Func1, но отбросывает возвращаемое значение. Для хранения возвращаемого значения создается временный объект.
```
**Временный объект** удаляется после завершения работы функции. Это означает, что для временной переменной будет вызван деструктор, который освобождает память по адресу, которая необходима для присваивания значения объекту

*Как избежать создания **временного объекта**?* - 
**Чтобы избежать создания временного объекта при возврате его из функции можно вмемто самого объекта возвращать ссылку или указатель на этот объект.**

***

# Вопрос 43
**Конструктор и деструктор: назначение, решаемые задачи, взаимодействие с средствами выделения памяти.**

**Конструктор** – это функция, которая работает в момент создания объекта класса.
* Конструктор имеет то же имя, что и класс.
* Конструктор ничего не возвращает, он настраивает значения полей и выделяет память под динамические массивы, которые используются в объекте.
* Чаще всего, конструкторы относятся к открытой зоне (public). 
* Конструктор служит для инициализации объяекта класса, поэтому его следует объявлять в `public`. *Стоит заметить, что в промышленном программировании могут встречаться случаи объявления конструктора в `private`. Конструктор помещается в секцию private в случаях, если нужно ограничить пользователя в возможностях создания объектов.* Пример:
```c++
class NonCopyable {
private:
   NonCopyable(const NonCopyable&) = delete;
   void operator=(const NonCopyable&) = delete;
};
```

При этом, зачастую конструкторов много для того, чтобы можно было в разных ситуациях давать разные наборы значений для атрибутов класса. Для того, чтобы этого добиться, применяется перегрузка функций.
  
Важное действие, которое производится в конструкторе, - это выделение памяти под динамические массивы, если они присутствуют в качестве атрибута класса.

Например, для класса строка `BaseString`, где

- `p` – указатель на первый элемент массива `char`
- `len` – количество заполненных элементов 
- `capacity` – объём выделенной памяти  

необходимо выделить память под массив `p`. В примере представлено два конструктора: конструктор с одним параметром и конструктор копий. 

```c++
class BaseString
{
private:
    char* p;
    int len;
    int capacity;
public:
    BaseString(char* ptr)
    {
        len = strlen(ptr) + 1;
        capacity = 256;
        p = new char[capacity];
        for(int i=0;i<len;i++)
        {
            p[i] = ptr[i];
        }
        p[len] = '\0';
    }
    BaseString(int Capacity = 256)
    {
        capacity = Capacity;
        p = new char[capacity];
        len = 0;
    }
//…
}
```

**Деструктор** - это функция, которя служит для освобождения выделенной конструктором под объект класса памяти и удаления самого объекта класса.

* Имеет то же имя, что и класс.
* Чтобы отличать деструктор от конструкторов, в названии
используют тильду `~`.
* Деструктор может быть только один – он не перегружается и не
принимает параметров. Так делается потому, что обычно он вызывается автоматически.

**Явные вызовы деструктора**
Редко возникает необходимость в явном вызове деструктора. Однако может быть полезно выполнить удаление объектов, размещенных по абсолютным адресам. Эти объекты обычно выделяются с помощью определяемого new пользователем оператора, который принимает аргумент размещения. Оператор delete не может освободить эту память, так как он не выделяется из свободного хранилища. Вызов деструктора, однако, может выполнить соответствующую очистку. Для явного вызова деструктора для объекта (s) класса String воспользуйтесь одним из следующих операторов.

**Порядок уничтожения:**

Когда объект выходит за пределы области или удаляется, последовательность событий при его полном уничтожении выглядит следующим образом:

* Вызывается деструктор класса, и выполняется тело функции деструктора.

* Деструкторы для объектов нестатических членов вызываются в порядке, обратном порядку их появления в объявлении класса. Список инициализации необязательных элементов, используемый при построении этих элементов, не влияет на порядок строительства или уничтожения.

* Деструкторы для не виртуальных базовых классов вызываются в обратном порядке объявления.

* Деструкторы для виртуальных базовых классов вызываются в порядке, обратном порядку их объявления.

Важно понимать, что деструктор класса вызывается для всех объектов имееющих тип класса (за исключением ссылок или указателей).

Например, деструктор класса `BaseString`, приведённого выше как пример, работает следующим образом:

```c++
class BaseString
{
protected:
    char* p;
    int len;
    int capacity;
public:
//…
    ~BaseString()
    {
        if(p!=NULL)
            delete[] p;
        len = 0;
    }
};
```

***

# Вопрос 44
**Какими функциями могут быть конструктор и деструктор (статическим и нестатическим методом класса, дружественной функцией, виртуальной функцией)? Почему? Аргументируйте ответ.**

Для ответа на данный вопрос для начала следует дать следующие определения:

### СТАТИСТИЧЕСКИЕ И НЕСТАТИСТИЧЕСКИЕ МЕТОДЫ КЛАССА.

Помимо переменных-членов статическими можно объявлять и функции-члены, но обычно это не делается. Доступ к объявленной статической функции — члену класса возможен только для других статических членов этого класса. У статической функции-члена нет указателя `this`. Статические функции-члены не могут быть виртуальными. Статические функции-члены не могут объявляться с идентификаторами `const` (постоянный) и `volatile` (переменный). И наконец, статические функции — члены класса могут вызываться любым объектом этого класса, а также через имя класса и оператор расширения области видимости без всякой связи с каким бы то ни было объектом этого класса.

Однако статические методы могут оказаться удобными для предварительной опеределения статических атрибутов до создания экземпляров или просто независимо от доступа к ним.

В C++ статические члены класса не инициализируются с помощью конструктора, поскольку они не зависят от инициализации объекта, хотя в некоторых языках программирования есть возможность инициализировать статические поля через статический конструктор. 

* **Дружественные функции** -
  Это такие функции, которые **имеют** доступ к `private` и `protected` полям класса. Не являются членами класса. Инициализируются в классе с помощью ключевого слова `friend`. 
  
* **Виртуальные функции** - 
  Это такие функции, которые могут быть переопределены в классах-наследниках так, что конкректная реализация метода вызова будет определяться во время исполнения (Run-time). Обозначаются ключевым словом `virtual`

**Исходя из всего вышеперечисленного, можно сделать выводы о следующем:** 

* Конструктор - это функция-член класса, имя которой совпадает с именем класса. Это помогает инициализировать объект класса. Он может либо принимать аргументы, либо нет. Он используется для выделения памяти объекту класса. Он вызывается всякий раз, когда создается экземпляр класса. Он может быть определен вручную с аргументами или без аргументов. В классе может быть много конструкторов. Он может быть перегружен, но не может быть унаследованным или виртуальным. Существует концепция конструктора копирования, который используется для инициализации объекта из другого объекта.

* Конструктор и деструктор не могут быть **дружественными** функциями, так как их нельзя переопределить и инициализировать вне класса. 
* Деструктор может быть **виртуальным**. Нужен для того, чтобы не происходило утечек памяти и вызывался нужный деструктор. (см. вопрос 7)

* Конструктор и деструктор являются **нестатическими** по умолчанию.

Разница между конструктором и деструктором в C ++ : 

| N |                        Конструктор                     |                        Деструктор |
|--|-------------|---------|
| 1. | 	Конструктор помогает инициализировать объект класса. |	В то время как деструктор используется для уничтожения экземпляров. |
| 2. |	Он объявляется как className(аргументы, если есть){Тело конструктора}. |	Тогда как он объявлен как ~ className(без аргументов){ }. |
| 3. |	Конструктор может либо принимать аргументы, либо нет.	| Хотя у него не может быть никаких аргументов. |
| 4. |	Конструктор вызывается при создании экземпляра или объекта класса. |	Он вызывается, когда объект класса освобождается или удаляется. |
| 5. |	Конструктор используется для выделения памяти экземпляру или объекту.	| В то время как он используется для освобождения памяти объекта класса. |
| 2. |	Конструктор может быть перегружен. |	Пока он не может быть перегружен.
| 3. |	Имя конструктора совпадает с именем класса.	| Здесь его имя также совпадает с именем класса, которому предшествует оператор tiled (~). |
| 4. |	В классе может быть несколько конструкторов. | В классе всегда есть один деструктор.
| 5. |	Существует концепция конструктора копирования, который используется для инициализации объекта из другого объекта. |	В то время как здесь нет концепции конструктора копирования. |
| 6. |	Они часто вызываются в последовательном порядке. |	Они часто вызываются в порядке, обратном конструктору. |

***

## Вопрос 45

**Можно ли перегружать конструктор? Почему?** 

**Ответ:**

В программах на C++ **перегрузка конструктора класса вполне обычна**. Имеется три основных причины перегрузки конструктора, которая, как правило, 
выполняется либо для обеспечения гибкости, либо для поддержки массивов, либо для создания конструкторов копий.

Необходимо запомнить одну вещь: **каждому способу объявления объекта класса должна соответствовать своя версия конструктора класса.** Если 
эта задача не решена, то при компиляции программы обнаружится ошибка. Именно поэтому перегрузка конструктора столь обычна для программ C++.

Изучить на более подробных примерах перегрузку конструкторов можно на [стр. 144](https://disk.yandex.ru/i/KoKMQ5xd3NhoMR) (или в вопросе 47)

***

## Вопрос 46

**Можно ли перегружать деструктор? Почему?** 

**Ответ:** 

Перегрузка означает наличие нескольких функций с одинаковым именем, которые принимают разные аргументы. **Деструктор не принимает аргументов, и поэтому перегрузка не имеет смысла.** Кроме того, деструктор вызывается автоматически и при его перегрузке программа не будет понимать, какой именно деструктор следует использовать.

Если вам нужно делать разные вещи при уничтожении объекта в зависимости от определенных обстоятельств, вам просто нужны соответствующие операторы 
`if` в вашем деструкторе для проверки этих обстоятельств.

***

## Вопрос 47

**Передача параметров в конструктор и перегрузка конструктора. Что можно сказать о перегрузке деструктора? Конструктор по умолчанию.** 

**Ответ:** 

Для каждого создаваемого вами объекта требуется какого-то вида инициализация. Для разрешения этой проблемы в C++ имеется **функция-конструктор** (constructor function), включаемая в описание класса. Конструктор класса вызывается всякий раз при создании объекта этого класса. Таким образом, любая необходимая объекту инициализация при наличии конструктора выполняется автоматически. Конструктор имеет то же имя, что и класс, частью которого он является, и не имеет возвращаемого значения. Для глобальных объектов конструктор объекта вызывается тогда, когда начинается выполнение программы. Для локальных объектов конструктор вызывается всякий раз при выполнении инструкции объявления переменной.

Конструктор, не требующий параметров, называется **конструктором по умолчанию**. Это может быть конструктор с пустым списком параметров или конструктор, в котором все аргументы имеют значения по умолчанию. Конструкторы могут быть перегруженными, но конструктор по умолчанию может быть только один.

В C ++ конструкторы по умолчанию имеют существенное значение, поскольку они автоматически вызываются при определенных обстоятельствах, и, следовательно, при определённых условиях класс обязан иметь конструктор по умолчанию, иначе возникнет ошибка:
1. Когда объект объявляется без аргументов (например, `MyClass x;`) или создаётся новый экземпляр в памяти (например, `new MyClass;` или `new MyClass();`).
2. Когда объявлен массив объектов, например, `MyClass x[10];`; или объявлен динамически, например `new MyClass [10]`. Конструктор по умолчанию инициализирует все элементы.
3. Когда в классе потомке не указан явно конструктор класса родителя в списке инициализации.
4. Когда конструктор класса не вызывает явно конструктор хотя бы одного из своих полей-объектов в списке инициализации.
5. В стандартной библиотеке определённые контейнеры заполняют свои значения используя конструкторы по умолчанию, если значение не указано явно. Например, `vector<MyClass>(10);` заполняет вектор десятью элементами, инициализированными конструктором по умолчанию.

Если определены конструкторы для класса, но среди них нет конструктора по умолчанию, компилятор создаст неявно таковой.

[//]: <> (//////////////////////////////////////////)
[//]: <> (компилятор создаст его неявно!)
[//]: <> (//////////////////////////////////////////)

Конструкторы по умолчанию являются одной из специальных функций-членов. Если конструкторы в классе не объявляются, компилятор предоставляет неявный `implicit` конструктор по умолчанию. Вы можете запретить компилятору создавать неявный конструктор по умолчанию, определив его как удаленный:
```c++
// Default constructor
    Box() = delete;
```
[//]: <> (//////////////////////////////////////////)
[//]: <> (лучше использовать ключевое слово `explicit`)
[//]: <> (//////////////////////////////////////////)

Или же явно указать его:
```c++
// Default constructor
    Box() = default;
```

[//]: <> (//////////////////////////////////////////)
[//]: <> (это не явное объявление конструктора по умолчанию, его создаст компилятор)
[//]: <> (//////////////////////////////////////////)

**Конструктору можно передавать аргументы**. Для этого необходимо просто добавить необходимые параметры в объявление и определение конструктора. Затем при
объявлении объекта задать параметры в качестве аргументов. Мы все это делали, все просто. В отличие от конструктора **деструктор не может иметь параметров**. Смысл
этого понять достаточно просто: **отсутствует механизм передачи аргументов удаленному объекту**. Подробнее про перегрузку деструктора в вопросе 46.

В программах на C++ перегрузка конструктора класса вполне обычна. Деструктор, однако, перегружать нельзя. **Имеется три основных причины перегрузки конструктора**:
1. для обеспечения гибкости; 
2. для поддержки массивов;
3. для создания конструкторов копий. 
    
**ПРИМЕР**

Одна из ситуаций, в которой вам потребуется перегрузить конструктор класса, возникает при выделении динамической памяти массиву объектов этого
класса. Известно, что динамический массив не может быть инициализирован. Поэтому, если в классе есть инициализирующий конструктор, вам необходимо включить туда и его перегруженную версию без инициализации. Например, ниже приведена программа, в которой массиву объектов динамически выделяется память.
```c++
#include <iostream>
using namespace std;
class myclass {
     int x;
public:
     // перегрузка конструктора двумя способами
     myclass () { x = 0; } // нет инициализации
     myclass (int n) { x = n; } // прямая инициализация
     int getx() { return x; }
     void setx(int n) { x = n; }
};
int main() {
     myclass *p;
     myclass ob(10); // инициализация отдельного объекта
     p = new myclass[10]; // здесь инициализировать нельзя
     if (!p) {
          cout << "Ошибка выделения памяти\n";
          return 1;
     }
     int i;
     // инициализация всех элементов значением ob
     for(i = 0; i < 10; i++) p[i] = ob;
     for(i = 0; i < 10; i++) {
          cout << "p[ " << i << "]:" << p[i].getx
          cout << '\n' ;
     }
     return 0;
}
```
[//]: <> (//////////////////////////////////////////)
[//]: <> (myclass [] { x = 0; } // нет инициализации)
[//]: <> (вообще-то здесь есть инициализация, и она больше похожа на прямую инициализацию или на инициализацию по умолчанию)
[//]: <> (//////////////////////////////////////////)
[//]: <> (вообще в кодике ошибки: посмотри https://github.com/Igetsuga/programming-practice/blob/master/fix.md я там расписал )
[//]: <> (//////////////////////////////////////////)

Без перегруженной версии конструктора `myclass()`, в которой отсутствует инициализация, оператор `new` при компиляции вызвал бы ошибку.

И совсем немного про конструктор копий (кажется, про него есть отдельный вопрос).

Одной из важнейших форм перегруженного конструктора является **конструктор копий** (copy constructor). Для начала давайте обозначим проблемы, для решения которых предназначен конструктор копий. Когда объект передается в функцию, происходит побитовое копирование, копия этого объекта и передается тому параметру
функции, который получает объект. Однако бывают ситуации, в которых такая точная копия объекта нежелательна. Например, если объект содержит
указатель на выделенную область памяти, то в копии указатель будет ссылаться на ту же самую область памяти, на которую ссылается исходный
указатель. Следовательно, если копия меняет содержимое области памяти, то эти изменения коснутся также и исходного объекта! Кроме того, когда
выполнение функции завершается, копия удаляется, что приводит к вызову деструктора этой копии. Вызов деструктора может привести к нежелательным побочным эффектам, которые в дальнейшем повлияют на исходный объект. Эта ситуация возникала в 6-ой практической, поэтому прелагаю разобрать ее более детально на примере линкед листа.

При копировании контейнера, такого как связанный список, вероятно, потребуется **глубокая копия**, поэтому необходимо создать новые узлы и скопировать только данные. Указатели и в узлах нового списка должны ссылаться на новые узлы, созданные специально для этого списка, а не на узлы из исходного списка. Эти новые узлы будут иметь копии соответствующих данных из исходного списка, так что новый список можно считать по значению или глубокой копией. Вот картинка, изображающая различия между неглубоким и глубоким копированием:

![image](https://user-images.githubusercontent.com/90936335/173569287-8770434b-7c8e-4683-9703-6965fe2a18f2.png)

Обратите внимание, что в части схемы Deep Copy ни один из узлов не указывает на узлы в старом списке. Для получения дополнительной информации о разнице между неглубокими и глубокими копиями см. [статью Википедии](https://en.wikipedia.org/wiki/Object_copying) о копировании объектов. 

Важно понимать, что в C++ точно разделяются два типа ситуаций, в которых значение одного объекта передается другому. Первая ситуация — это присваивание. Вторая — инициализация, которая может иметь место в трех случаях:

1. Когда в инструкции объявления объекта один объект используется для инициализации другого.
2. Когда объект передается в функцию в качестве параметра
3. Когда в качестве возвращаемого значения функции создается временный объект.

**Конструктор копий употребляется только для инициализации, но не для присваивания. Для второго необходим оператор присваивания**

## Вопрос 48

Наиболее эффективный способ определения конструктора дочернего класса - унаследоваться от родительского, если это возможно, так можно избежать ненужных выделений памяти и лишних операций.

***

## Вопрос 49
**Потоковый ввод/вывод в C++. Перегрузка операций для этого и манипуляторы ввода/вывода.**

В ```c++``` нет встроенных средств ввода-вывода, поэтому используется библиотека `iostream` ввода-вывода.


В данной библиотеке определяются три стандартных потока:
* ```cin``` - стандартный входной поток (stdin в С)
* ```cout``` - стандартный выходной поток (stdout в С)
* ```cerr``` - стандартный поток вывода сообщений об ошибках (stderr в С)

Для выполнения операций ввода-вывода переопределены две операции поразрядного сдвига:
* ```>>```  - получить из входного потока (служит для ввода информации)
* ```<<```  - поместить в выходной поток (служит для вывода информации)

Возможно многократное назначение потоков: 
```c++
cin >> переменная_1 >> переменная_2 >> ... >> переменная_n;
```

В некоторых классах требуется переопределение операторов потокового ввода/вывода.м

Расмотрим следующий пример:
```c++
class Point
{
private:
    double m_x{}; 
    double m_y{};
    double m_z{};
public:
    Point(double x=0.0, double y=0.0, double z=0.0) : m_x{x}, m_y{y}, m_z{z} {}

    friend std::ostream& operator<< (std::ostream &out, const Point &point);
    friend std::istream& operator>> (std::istream &in, Point &point);
};
```
Для вывода полей данного класса нужна перегрузка ```operator<<```.
Для ввода полей данного класса нужна перегрузка ```operator>>```.
```c++
std::ostream& operator<< (std::ostream &out, const Point &point)
{
     out << "Point(" << point.m_x << ", " << point.m_y << ", " << point.m_z << ')';
     return out;
}
std::istream& operator>> (std::istream &in, Point &point)
{
    in >> point.m_x >> point.m_y >> point.m_z;
    return in;
}
```
После переопределения данных операторов можно использовать их для стандартного ввода/вывода значений полей заданного класса.
```c++
int main()
{
    Point point{};
    std::cin >> point; // Ввод
    std::cout << point; // Вывод
    return 0;
}
```
**Манипуляторы потока** - Это такая функция, которая позволяет форматировать данные для ввода/вывода.

* Функцию - манипулятор потока можно включать в операции помещения в поток и извлечения из потока (`<<`, `>>`).

Пример манипулятора перевода значений из 10-ой в 16-ую систему счистления:

```c++
ostream& my_manip(ostream& stream)
{
	stream.unsetf(ios::dec);
	stream.setf(ios::hex);
	return stream;
}
```

Существует множество манипуляторов потока, однако наиболее используемые из них: 
* ```endl``` - манипулятор перехода на новую строку при выводе;
* ```boolalpha``` - манипулятор вывода логических величин в текстовом виде;
* ```noboolalpha``` - манипулятор вывода  логических величин в числовом виде;
* ```oct```,```dec```,```hex``` - ввод/вывод величин в соответствующих системах счистления;
* ```showbase``` - вывод индикатора основания системы счистления;
* ```scientific``` - вывод чисел с плавающей точкой в экспоненциальной форме;
* ```fixed``` - вывод чисел с плавающей точкой в фиксированном формате.

***

## Вопрос №50 и 51.

### Способы наследования `private`, `protected`, `public` и спецификаторы в родительском классе `private`, `protected`, `public`.

Спецификаторы доступа:
- `public` - доступ открыт всем;
- `protected` — доступ открыт только классам, производным от данного;
- `private` — доступ открыт самому классу и друзьям (`friend`) данного класса: как функциям, так и классам. Однако даже производные классы не получают доступа к этим данным.

```cpp
class MyClass {
  
  public:    // Public access specifier
    int x;   // Public attribute
  
  protected:   // Protected access specifier
    int y;   // Protected attribute
  
  private:   // Private access specifier
    int z;   // Private attribute
    
};
class MyChild : public MyClass {
   public:
      void poke()
      {
         x = 10;     // Allowed (public)
         y = 1010;   // Allowed (protected)
         z = 101010; // Not allowed (private)
      }
};
int main() {
  MyClass myObj;
  myObj.x = 25;  // Allowed (public)
  myObj.y = 50;  // Not allowed (protected)
  myObj.z = 75;  // Not allowed (private)
  
  return 0;
}
```

Типы наследования:
- публичный (`public`) - публичные (`public`) и защищенные (`protected`) данные наследуются без изменения уровня доступа к ним;
- защищенный (`protected`) - все унаследованные данные становятся защищенными (`protected`);
- приватный (`private`) - все унаследованные данные становятся приватными (`private`).

---

## Вопрос №52.

### Что доступно в классе, порождённом от порождённого от базового (2 ступень наследования) при первичном наследовании `public`?

Всё, кроме того, что имеет спецификатор доступа `private`. `public` остается `public`-ом, `protected` остается `protected`-ом. Пример:

```cpp
class MyClass {
public:
    int x;   // Public attribute
protected:
    int y;   // Protected attribute
private:
    int z;   // Private attribute
};
class MyChild : public MyClass {
public:
    int a;   // Public attribute
protected:
    int b;   // Protected attribute
private:
    int c;   // Private attribute
};
class MyGrandChild : public MyChild {
public:
    void poke()
    {
        x = 10;     // Allowed (public)
        y = 1010;   // Allowed (protected)
        z = 101010; // Not allowed (private)
        a = 1;    // Allowed (public)
        b = 11;   // Allowed (protected)
        c = 111;  // Not allowed (private)
    }
};
```

---

## Вопрос №53.

### Что доступно в классе, порождённом от порождённого от базового (2 ступень наследования) при первичном наследовании `protected`?

Аналогично случаю из 52-го вопроса: из самого класса-внука будут доступны все `protected` и `public` методы и атрибуты ребёнка, причем доступ `protected` будет иметь всё, что досталось от родителя.

---

# Вопрос 54

Обращение к члену родительского класса извне возможно только если он не является абстрактным. Обращение извне происходит также как к любому классу: через операторы `.*` и `->*`.
Операторы `.*` указателя на члены и `->*` возвращают значение определенного члена класса для объекта, указанного слева от выражения. Правая часть должна определять член класса. В следующем примере показано использование этих операторов.
```cpp
#include <iostream>
using namespace std;
class Testpm
{
public:
   void m_func1() { cout << "m_func1\n"; }
   int m_num;
};
void (Testpm::*pmfn)() = &Testpm::m_func1;
int Testpm::*pmd = &Testpm::m_num;
int main()
{
   Testpm ATestpm;
   Testpm *pTestpm = new Testpm;
   (ATestpm.*pmfn)();
   (pTestpm->*pmfn)();
   ATestpm.*pmd = 1;
   pTestpm->*pmd = 2;
   cout  << ATestpm.*pmd << endl
         << pTestpm->*pmd << endl;
   delete pTestpm;
}
```
Выходные данные
```
m_func1
m_func1
1
2
```
В приведенном выше примере указатель на член, `pmfn`, используется для вызова функции-члена `m_func1`. Другой указатель на член, `pmd`, используется для обращения к члену `m_num`.

Бинарный оператор `.*` объединяет свой первый операнд, который должен быть объектом типа класса, со вторым операндом, который должен быть типом указателя на член.

Бинарный оператор `->*` объединяет свой первый операнд, который должен быть указателем на объект типа класса, со вторым операндом, который должен быть типом указателя на член.

В выражении, содержающем `.*` оператор, первый операнд должен иметь тип класса и быть доступным для элемента, указанного во втором операнде или доступном для этого класса.

В выражении, содержающем `->*` оператор, первый операнд должен иметь тип "указатель на тип класса" типа, указанного во втором операнде, или он должен быть однозначно производным от этого класса.

Обращение из производных классов происходит через оператор `::`, т.е. используя пространство имен родительского класса.

```cpp
class A
{
public:
   int a;
   void foo(){}
};
class B : public A
{
public:
   int b;
   void foo()
   {
      A::foo();
   }
};
```

***

# Вопрос 55

Если два идентичных идентификатора вводятся в одну и ту же программу таким образом, что компилятор или компоновщик не может их различить, компилятор или компоновщик выдаст ошибку. Эта ошибка обычно называется конфликтом имен (или коллизией имен).

Большинство конфликтов имен возникают в двух случаях:
1. Два (или более) определения функции (или глобальной переменной) вводятся в отдельные файлы, которые компилируются в одну программу. Это приведет к ошибке компоновщика, как показано выше.
2. Два (или более) определения функции (или глобальной переменной) вводятся в один и тот же файл (часто через #include). Это приведет к ошибке компилятора.

Пространство имен – это область, которая позволяет вам объявлять имена внутри него с целью устранения неоднозначности. Пространство имен обеспечивает область видимости (называемую областью пространства имен) для имен, объявленных внутри него, что просто означает, что любое имя, объявленное внутри пространства имен, не будет ошибочно принято за идентичные имена в других областях видимости. Имя, объявленное в пространстве имен, не будет ошибочно принято за идентичное имя, объявленное в другой области видимости.

Для разрешения конфликта были созданы пространства имен.

# Вопрос 56

## Определения: 
* Наследование: класс может унаследовать — использовать по умолчанию — поля и методы своего предка. Наследование транзитивно: класс может наследоваться от другого класса, который наследуется от третьего, и так далее вплоть до базового класса, возможно, неявного. Наследник может переопределить какие-то методы и поля чтобы изменить поведение по умолчанию.
* Композиция: если поле у нас имеет тип Класс, оно может содержать ссылку на другой объект этого класса, создавая таким образом связь между двумя объектами. "На пальцах" определим: композиция — когда один объект предоставляет другому свою функциональность частично или полностью.

Для чего нужна композиция — из частей собрать целое. А вот с наследованием сложнее, потому что оно сразу о двух вещах: о смысле и о механике.

### Наследование смысловое
Как в биологии классификация таксонов организует их в иерархии, так наследование отражает иерархию понятий из предметной области. Упорядочивает их от общего к частному, собирает родственные идеи в ветви иерархического древа. Смысл (семантика) класса по большей части выражен в его интерфейсе — наборе сообщений, которые класс способен понять, но также определяется и теми сообщениями, которыми класс отвечает. Унаследовался от предка — будь добр не только понять все сообщения, которые мог понять предок, но также и уметь ответить как он (сохранить поведение предка — прим. пер.) И поэтому наследование связывает наследника с предком гораздо сильнее, чем если бы мы взяли просто экземпляр предка как компонент. Обратите внимание, даже если класс делает что-то совсем простое, почти не имеет логики, его имя несет существенную смысловую нагрузку, разработчик делает из него важные выводы о предметной области.

### Наследование механическое
Говоря о наследовании в механическом плане, мы имеем в виду, что наследование берет данные (поля) и поведение (методы) базового класса и позволяет использовать их повторно или же дополнить в наследниках. С точки зрения механики, если потомок унаследует реализацию (код) предка, то неизбежно получит и его интерфейс.

***

# Вопрос 57

Доступ к члену класса работает быстрее при вставке класса, так как при наследовании нам нужно обратиться сначала к наследнику, а потом к его родительскому классу.

***

## Вопрос 58

**Что такое множественное наследование, какие могут возникнуть проблемы? Как они решаются?**

**Ответ:** 
1. Наследование при котором класс-потомок имеет более одного родительского класса называется **множественным** (_Multiple inheritance_). Конечно, как и при обычном наследовании производному классу доступны методы и атрибуты в зависимости от типа наследования (`private`, `protected`, `public`). Отметим, что наследование от каждого из родительских классов может быть разным. Для лучшего понимая предлагаем вам взглянуть на следующий пример, в котором представлено множественное наследование класса `D`
    ```c++
    #include <limits>
    class A 
    {
    public:
        int a3;
        const int& get_a3() const { return a3; }
    protected:
        int a2;
        const int& get_a2() const { return a2; }
    private:
        int a1;
        const int& get_a1() const { return a1; }
    };
    class B 
    {
    public:
        int b3;
        const int& get_b3() const { return b3; }
    protected:
        int b2;
        const int& get_b2() const { return b2; }
    private:
        int b1;
        const int& get_b1() const { return b1; }
    };
    class C 
    {
    public:
        int c3;
        const int& get_c3() const { return c3; }
    protected:
        int c2;
        const int& get_c2() const { return c2; }
    private:
        int c1;
        const int& get_c1() const { return c1; }
    };
    class D : private A, protected B, public C 
    {
    protected:
        int d; // внутри класса `D` можно получить доступ к атрибутам и методам наследуемых классов.
        
        void function()
        {
            // методы класса `A`
            d = A::get_a3(); // доступно
            d = A::get_a2(); // доступно
            d = A::get_a1(); // ошибка доступа
            // методы класса `B`
            d = B::get_b3(); // доступно
            d = B::get_b2(); // доступно
            d = B::get_b1(); // ошибка доступа
            // методы класса `C`
            d = C::get_c3(); // доступно
            d = C::get_c2(); // доступно
            d = C::get_c1(); // ошибка доступа
        }
    };
    ```
 
2. Но при множесвенном наследовании может возникнуть проблема, которая получила название "ромбовидное наследование (_diamond inheritance_))". Представим ромбовидное наследование.
    ```c++
    class A {};
    class B : public A {};
    class C : public A {};
    class D : public B, public C {};
    ```
    Пусть в классе `D` будет вызван метод класса `A`, который не был переопределен в классе `D`, но был переопрделен в каждом из классов  `B` и `C`, тогда какой из этих трех методов должен быть вызван?
    (На самом деле c++ не создает такой проблемы. При создании экземпляров классов `B` или `C` сначала будет вызван один из конструкторов класса `A`, и только потом конструкторы производных классов, т.е. сначала будет создан объект типа `A`, а потом объекты производного класса. 
    
    Но тогда при создании экземпляра класса `D` будут созданы экземпляры классов `B` и `C`, что приведет к двойному вызову конструктора класса `A` = будет создано два объекта базового класса: `B::A` и `C::A`. Тогда при использовнии методов класса `A` необходимо указать путь наследования, например `C::A::function()`) 
3. Чтобы решить проблему ромбовидного наследования было введено виртуальное наследование. Мы объявляем наследование классов `B` и `C` от класса `A` виртуальным.
     ```c++
    class A {};
    class B : virtual public A {};
    class C : virtual public A {};
    class D : public B, public C {};
    ```
    Тогда компилятор проследит за созданием только одного объекта класса `A`, что позволит пользоваться его методами без указания пути наследования. 
    **А что если мне неймется и я сделаю так?**
     ```c++
    class A {};
    class B : virtual public A {};
    class C : public A {};
    class D : public B, public C {};
    ```
    Тогда при объявлении объекта класса `D` будут созданы: выртуальный объект класса `A` (не знаю зачем он) и по одному невиртуальному объекту класса `A` по каждому из путей наследования, т.е. объекты `D::B::A` и `D::C::A`. Если не работать с указателями на базовый класс, то действовать можно так же, как и при полностью виртуальном наследовании, иначе если указатель на базовый класс смотрит на объект класса `D` и мы вызываем **виртульный** метод `A::insert(...)`, который был переопределен в классах `B` и `C` как `D::insert(...)` и `C::insert(...)`, то компилятор выдаст ошибку из-за [принципа доминирования](https://en.wikipedia.org/wiki/Dominance_(C%2B%2B)).
А вот [здесь](https://github.com/Igetsuga/programming-practice/blob/master/object-oriented-programming/practice3%5BInheritance%5D.cpp) можно найти пример с ромбовидным наследованием с комментариями.
___
## Вопрос 59
**Виртуальные функции: способы задания, отличия от невиртуаль-ных. Приведите сравнение на простом примере.**
    
**Ответ:** 
1. Зачем нужны виртуальные методы? При работе с указателем на базовый класс мы хотим вызвать метод, который был переопределен в производном классе, тогда если в базовом классе этот метод не объявлен как виртуальный, то будет вызван метод родительского класса, иначе нужный нам у производного. Таким образом, виртульные методы указывают компилятору на переопределенные методы, которые нужно вызвать в данный момент.
2. Чтобы объявить метод виртуальным необходимо использовать ключевое слово `virtual`. Пример, метод `Base::GetPosition()` объявлен виртуальным.
    ```c++
    class Base 
    {
        virtual const int& GetPosition() const final;
    };
    ```
3. Виртуальные методы от невиртуальных отличаются тем, что у первых **динимаческое связвывание**(_разрешение типов во время выполнения программы_), т.е. связываение вызова функции с её определением происходит во время выполнения программы, а у вторых во время компиляции, потому что виртульная функция может быть переопределена в другом месте, и тогда сначала нужно понять какой из всех вариантов вызывать. Чтобы понять какой из всех вариантов вызвать нужен контекст (например, знать на что смотрит указатель на базовый класс), который определяется работой программы. Пример, убрав в нем виртуальность метода базового класса `print()`, мы вызовем метод из базового класса дважды(**проверьте сами**)
    ```c++
    #include <limits>
    #include <iostream>
    class Base 
    {
    public:
        Base() = default;
        ~Base() = default;
        virtual void print() const 
        {
            std::cout << '\n' << "I am frome Base" << '\n';
        }
    };
    class Derived : public Base
    {
    public:
        Derived() = default;
        ~Derived() = default;
        void print() const override
        {
            std::cout << '\n' << "I am frome Derived" << '\n';
        }
    };
    int main()
    {
        Base base;
        Derived derived;
        Base* ptr = &base; ptr->print();
        ptr = &derived; ptr->print();
        return 0;
    }
    ```
    Вывод:
        I am frome Base
        I am frome Derived
___
## Вопрос 60
**Что будет, если в родительском классе функция объявлена как вир-туальная, в унаследованном от него – нет?**
    
**Ответ:** 
   1. Для того, чтобы метод стал виртуальным **необходимо и достаточно**, чтобы он был объявлен виртуальным в базовом классе. Поэтому этот метод будет виртуальным для всех производным структур, где он переопределен. (см. пример из прошлого вопроса)
___
## Вопрос 61
**Имеется иерархия порождения классов A<-B<-C. Что будет в классе C, если в A функция была объявлена как обыкновенная, в B - как чисто вирту-альная, а в C - снова как обыкновенная?**
    
**Ответ:**     
Пусть метод `A::drink()` - обычный. `B::drink()` - чисто виртуальный. В таком случае работа метода `C::drink()` будет напрямую зависеть от того, с каким указателем мы имеем дело. Если указатель на базовый класс имеет тип `A`, то поскольку в классе `A` функция не была объявлена как виртуальная, а указатель смотрит на объект любого из классов `A` или `C`, то будет вызвана функция из базового класса, т.е. из класса `A`. Если указатель имеет тип `B`, а функция чисто-виртуальная (т.е. сам класс чисто-виртуальный) то он может смотреть только на объект класса `C`, в итоге, будет вызван метод из класса `C`. Это показывает следующий пример. 
```c++
#include <limits>
#include <iostream>
class A 
{
public:
	A() = default;
	~A() = default;
	void print() const 
	{
		std::cout << '\n' << "I am frome A" << '\n';
	}
};
class B : public A
{
public:
	B() = default;
	~B() = default;
	virtual void print() const = 0;
};
class C : public B 
{
public:
	C() = default;
	~C() = default;
	void print() const override
	{
		std::cout << '\n' << "I am frome C" << '\n';
	}
};
int main()
{
	
	C object_c;
	A* ptr_A = &object_c; ptr_A->print();
	B* ptr_B = &object_c; ptr_B->print();
	return 0;
}
```
Вывод:
    I am frome A
    I am frome C
___
## Вопрос 62
**Виртуальные методы и абстрактные классы: назначение, отличия от обычных.**
    
**Ответ:** 
1. Класс называется абстрактным, если хотябы один из его методов объявлен как чисто-виртульный. Философия абстрактных класов слудующая.
> Абстрактные классы используются в качестве обобщенных концепций, на основе которых можно создавать более конкретные производные классы. Хороший пример есть в ответе 7 или 17
Чтобы объявить метод класса чисто-виртуальным нужно приравнять виртуальную функцию приравнять к 0 во время её объявления.
    
```c++
    virtual void GetData() = 0;
```
Мы предпочитам объявлять чисто-виртуальные конструкторы и деструкторы. 
   
2. В отличие от стандартных классов у абстрактных есть некоторые ограничения.
    Абстрактные классы нельзя использовать для:
    - переменных и данных членов;
    - типов аргументов;
    - типов возвращаемых функциями значений;
    - типов явных преобразований.
    
    **Другими словами невозможно создать объект абстрактного класса. Однако можно использовать указатели и ссылки на абстрактные типы классов.**
    ___
## Вопрос 63
**Зачем нужны абстрактные классы?**
    
**Ответ:** 
1. см. Вопрос 62
2. Например, удобно будет объявить класс `Млекопитающие` абстрактным. Объвить там чисто-виртуальные методы: кормление молоком, живорождение. Унаследовать от класса `Млекопитающие` классы `Обезьянка`, `Свинка`, `Коровка`, `Кошечка`, `Собачка`, `Человечина`. В каждом из них опрделить методы базового класса. 
3. Обязательно посмотрите еще раз примеры в вопросах 7, 17. Они очень хорошие 
___
## Вопрос 64
**Статическое и динамическое связывание в контексте указателей на классы в иерархии порождения и преобразования типов C++.**
    
**Ответ:** 
1. Что такое связывание? Связываением называется соединение компилятором места, где функция была вызвана с тем местом, где она объявлена, а после определена. Когда функция вызывается управление программой в коцне концов переходит ячекам памяти, где эта функция определена. Или еще один пример, привязка переменной к типу тоже является связываением (т.е. `int x` здесь переменная `x` связывается с типом `int`)
2. Есть всего два вида связывания: **статическое**(_ранее_) и **динамическое**(_позднеее_), они уже были затронуты ранее, см. Вопрос 59, но, все равно, здесь еще раз объясним разницу. 
    >Связывание является **статическим**, если оно впервые происходит перед запуском программы и остается неизменным на протяжении ее исполнения.
    >Связывание является **динамическим**, если оно впервые происходит во время исполнения или может измениться во время исполнения программы.
___
## Вопрос 65
**Имеются ли хоть какие-то проверки допустимости преобразований при динамическом связывании?**
**Ответ:** 
___
## Вопрос 66
**Сложное наследование (несколько предков). Последовательность вызовов конструкторов и деструкторов для объектов производного класса в этом случае.**
**Ответ:** 
1. Сложное наследование. Вызов конструкторов сверху-вниз (сначала базовый потом производный).
2. Сложное наследование (не виртуальное). Вызов деструкторов снизу-вверх (сначала производный потом базовый).
    ```c++
    #include <limits>
    #include <iostream>
    class A {
    public:
        A() { std::cout << '\n' << "A constructor"; }
        ~A() { std::cout << '\n' << "A destructor"; }
    };
    class B : public A
    {
    public:
        B() { std::cout << '\n' << "B constructor"; }
        ~B() { std::cout << '\n' << "B destructor"; }
    };
    class C : public B 
    {
    public:
        C() { std::cout << '\n' << "C constructor"; }
        ~C() { std::cout << '\n' << "C destructor"; }
    };
    int main ()
    {
        C object_c;
    return 0;
    }
    ```
    Вывод:
        
        A constructor
        B constructor
        C constructor
        C destructor
        B destructor
        A destructor

## Вопрос 67

**Генерация и обработка исключительных ситуаций: является ли необходимой, чем обусловлено её введение, как осуществляется (правила перехватывания).**

**Ответ:** 

**Почему необходимо создавать систему поиска и обработки исключений?**

Ошибки программы делятся на две категории: 
- **логические ошибки**, вызванные ошибками программирования, например, ошибкой «index out of range» 
- Run-time ошибки, которые выходят за рамки управления программистом, например, пользователь пытается посчитать определитель у неквадратной матрицы.

Если мы не напишем систему, которая будет работать с этими ошибками, то при каждой такой ошибке программа будет экстренно останавливать свою работу, а пользователь или программист, возможно, даже не поймут причины этих выходов. 

В современном C++ предпочтительным способом сообщить пальзователю о логических ошибках и об ошибках во время выполнения и обработать их - ввести исключения. Особенно это важно, когда стек может содержать что-то(другие функции) между вызовом функцией, которая ошибку находит и функцией, которая эту ошибку обрабатывает. Исключения же в момент обнаружения ошибки двигают функцию, которая её обрабатывает вверх по стеку.

**Является ли необходимой?** - да, даже если вы уверены в своих способностях и в наличии разума у пользователя, мы все равно хотим создат продукт, который невозможно "сломать".

**Правила перехвата ошибок**

1. Искючения становятся доступны для поимки, если они были выброшены: оператор `throw`. Искючения ловятся и обрабатываются в блоке `try` оператором `catch`. 
2. Исключения будет перехвачено первым оператором `catch`, тип которого совпадет с типом исключения. Если есть система наследования исключений, то исключение базового класса ловит все искючения производных классов. 
3. Если для некоторого класса нет обрабочика, и при этом такое исключение было выбрашено, программа завершит свое выполнение.

**Рекомендации**
 
1. Все классы исключений рекомендуется прямо или косвено(через базовый класс) наследовать от `std::exception`
2. Генерируйте исключения по значению, перехватывайте — по ссылке(обычно константная)
3. При ООП используйте исключения вместо кодов возврата. Есть мнение, что последовательно выбрасывание большого (10.000) количества исключений сильно замендляет код. Кто-то за, кто-то против, [например](https://habr.com/ru/post/130611/), оставляю ответ на это вам. 

___

## Вопрос 68

**Что будет, если для некоторого класса исключительных ситуаций нет обработчика?**

**Ответ:** 

Если для некоторого класса нет обрабочика, и при этом такое исключение было выбрашено, программа завершит свое выполнение.

Поэтому, нам (Рустему) кажется, что последние операторы `catch` должны ловить все исключения и обрабатывать их общим способом.

```c++
try {
    ...
}
catch (const networkIOException& e) {
    // ...
   cerr << e.what();
}
catch (const myDataFormatException& e) {
   // ...
   cerr << e.what();
}
catch (const std::exception e) {
    // ...
}
catch (...) { // ловит любое исключение 
    // ...
} 
```

___

## Вопрос 69

**Что будет, если один класс исключительных ситуаций порождён от другого?**

**Ответ:**

Ничего не будет

___

## Вопрос 70

**Бывают ли такие функции, в которых принципиально нельзя генерировать исключительные ситуации?**

**Ответ:**

Не бывает, но выбрасывать исключения стоит очень аккуратно. Когда вы выбрасывает исключение в функции, права выполнения переходят к обработчику исключений. Например, вы выбросили исключение `OutOfRange`  в деструкторе, обработчик обработал её, но больше в десруктор программа не вернется, поэтому экземляр может не быть удален или если имеем дело с конструктором, то создание экземляра не произойдет. Кроме того, не рекомендуется выбрасывать искючение конструкторе перемещения, т.к. теряется производительность этого конструктора(а он нам только для скорости и нужен). Пример: в сроке 40 было брошено исключение, строка 42 стала бесполезной.
```c++
class Exception : std::exception {
private:
    const char *_message = "otvali ot menya, che pristal to";
public:
    Exception() = default;
    ~Exception() = default;
    const char* what() const noexcept override { return _message; }
}; 
class Complex {
public:
    
    Complex() = default;
    Complex(double Re, double Im) {
        _Re = Re;
        _Im = Im;
    }
    ~Complex() = default;
    explicit Complex (double Re) { // строка 16
        _Re = Re; 
        _Im = 0;
    }
    friend void _print(const Complex &complex);
private:
    double _Re;
    double _Im;
};
void _print(const Complex &complex) {
        std::cout << '\n' << "Re = " << complex._Re;
        
        throw Exception(); // строка 40
        
        std::cout << '\n' << "Im = " << complex._Im; // строка 42
}
int main() {
    try {
        Complex z(23.1, 0.42); _print(z); // строка 47
    }
    catch (const Exception &e) {
        std::cout << '\n' << e.what() << '\n';
    }
    return 0;
}
``` 
Вывод:  
    
    Re = 23.1
    otvali ot menya, che pristal to

___

## Вопрос 70

**Классы памяти в C++: автоматический, динамический, временный, статический, внешний, регистровый: различия в поведении и использовании.**

**Ответ:** рекомендую почитать [это](https://teccxx.neocities.org/mx1/memory.html) и [это](https://habr.com/ru/post/527044/)


1. **Автоматическая**. Автоматические переменные создаются при входе в функцию и уничтожаются при выходе из неё. Они видны только внутри функции или блока, в которых определены. НЕ ПУТАТЬ С `auto variable = 9;` - это не автоматическая память.

2. **Динамическая.** Выделение памяти из ОС по требованию приложения. Используется, когда мы точно не знаем сколько памяти нам потребуется для объекта. Для создания и очищиния используются операторы `new`, `delete` ; `malloc`, `free`

3. `extern` — **глобальная** (внешняя) переменная. Внешние переменные доступны везде, где описаны, а не только там, где определены. Использование ключевого слова `extern` позволяет функции использовать внешнюю переменную, даже если она определяется позже в этом или другом файле. Для таких переменных связывание с адресом происходит на этапе компоновки(линкинг).

4. `register` — **регистровая** переменная (локальная). Это слово является всего лишь «рекомендацией» компилятору помещать часто используемую переменную в регистры процессора для ускорения программы. Т.е. такие переменные отличаются от автоматических только местом хранения.

5. **Временная** (промежуточная) память — память для хранения промежуточных результатов обработки. (~ автоматической)

6. `static` — **статическая** переменная (локальная). Пожалуйста, прочитайте эту [статью](https://habr.com/ru/post/527044/). Она очень хорошо написана, поэтмоу нет смысла делать из неё выжимку.


| Ключевое слово |    Класс памяти     |   Где находится    |       Создание        |         Удаление |
|----------------|:-------------------:|:------------------:|:---------------------:|-----------------:|
|                |    автоматическя    |       Stack        |     Compile-time      |         Run-time |
|                |    динамическая     |        Heap        |       Run-time        |         Run-time |
| `extern`       | глобальная(внешняя) |    Общая память    | Compile-time(Linking) | exit(after main) |
| `register`     |     регистровая     | Кеш или регистр ЦП |       Run-time        |         Run-time |
|                |      временная      | Оперативная память |       Run-time        |         Run-time |
| `static`       |     статическая     |    .data и .bss    | Run-time\Compile-time | exit(after main) |
___

## Вопрос 72

**Когда вызываются конструкторы статических атрибутов класса?**

**Ответ:** см. Вопрос 71 п.6

___

## Вопрос 73

**Что дальше будет происходить со временным объектом после завершения его создавшей функции?**

**Ответ:** будет вызван деструктор этого объекта

# Шаблоны С++

**Шаблоны позволяют достичь одну из самых трудных целей в программировании — создать многократно используемый код.**

**Используя шаблоны, можно создавать обобщенные функции и классы.**

**В обобщенной функции (или классе) обрабатываемый тип данных задается как параметр. Таким образом, одну функцию или класс можно использовать для разных типов данных, не предоставляя явным образом конкретные версии для каждого типа данных.**
___
# Вопросы 74-93

## Вопрос 74

**Шаблоны функций: назначение, определение, применение.**

**Ответ:** 

Шаблоны функций позволяют создать **обобщенную функцию. Обобщенная функция** определяет общий набор операций, которые предназначены для применения к данным различных типов. Тип данных, обрабатываемых функцией, передается ей как параметр. Используя обобщенную функцию, к широкому диапазону данных можно применить единую общую процедуру. Создавая обобщенную функцию, можно определить природу алгоритма независимо от типа данных. После этого компилятор автоматически генерирует корректный код для типа данных, который в действительности используется при выполнении этой функции (если обобщенная функция никак не используется, она вообще не будет затронута компилятором). По сути, создавая обобщенную функцию, вы создаете функцию, которая автоматически перегружает саму себя.

Обобщенная функция создается с помощью ключевого слова `template`.
```c++
template<class Type>
Type _min(Type a, Type b){
    if( a < b) {
        return a;
    }
    return b;
}
```

Примечание: вместо `class` можно использовать `typename`.

`template-спецификация` должна стоять непосредственно перед определением функции. Между ними не может находиться ни инструкция объявления переменной, ни какая-либо другая инструкция.

Также важно понимать, что можно указать несколько обобщенных типов, например:
```c++
template<class Type1, class Type2>
void greeting(Type1 a, Type2 b){
    std::cout << "Hello, Type1 and Type2!" << a << " " << b;
}
```
Type1 и Type2 могут совпадать, а могут и отличаться, в этом и вся прелесть.

Если простыми словами: у нас есть код, которому вообще все равно с каким типом данных работать, а писать одно и то же для каждого типа отдельно никто не станет, это ужасно. Здесь нам и помогают шаблоны - просто вместо конкретного типа используем параметризованный тип, компилятор уже сам решит, какие варианты нужно использовать. Здесь главное, чтобы каждый тип данных, подставляемый в функцию, соответствовал функционалу функции. Например в примере функция ищет минимальное значение среди двух, но если бы мы хотели передать туда свой класс, например `Student`, то нужно было бы определить для него оператор сравнивания `<`.
___
## Вопрос 75

**Что позволяют шаблоны и не позволяет препроцессор Си?**

## Вопрос 76

**Что позволяет препроцессор Си и не позволяют шаблоны?**
    
**Ответы:** 

Во-первых, **препроцессор** - программа, которая подготавливает код программы на языке Си к компиляции (для С++ тоже такое есть, но тут вопрос про Си). 

Я так понимаю, здесь под “позволяет препроцессор Си” имеются в виду **директивы препроцессора**. Для понимания рассмотрим директиву препроцессора для подстановки имен – `define`. 
Два примера использования `define`:
```c++
#define HELLO "Привет!"
#define MIN(a, b) (((a)<(b)) ? a : b) 
int main() {
  int x, y;
  x = 10;
  y = 20;
  cout << HELLO;
  cout << "Минимум равен: " << MIN(x, у);
  return 0;
} 
```

По сути у нас есть какое-то выражение или значение, и мы даем этому делу имя. В программе мы можем использовать это имя везде, где захотим (`define` обычно используется в начале файла).

Так вот, отвечая на вопросы.

Шаблоны позволяют избежать повторов в коде, возлагая выбор, с каким же типом генерировать функцию, на компилятор. Это довольно эффективно по памяти, но время какое-то займет.

`define` скорее же позволяет использовать часто встречающиеся вещи (будь то число, строка или операция) в более короткой форме. В таком случае ещё до компиляции вместо, например,  `HELLO` будет подставлено "Привет!". А в случае с `MIN(a, b)` - оно не работает как функция, на деле строка с выводом перед компиляцией примет следующий вид:
```c++
cout << "Минимум равен: " << (((x)<(y)) ? x : y);
```
Никаких вызовов функции не происходит, происходит текстовая замена перед компиляцией. Это довольно неэффективно по памяти, так как мы могли бы использовать `MIN(a, b)` в других местах, а значит было бы много повторов. Но зато это эффективно по времени - нет вызовов функций. 

Вообще есть различный директивы препроцессора, и, комбинируя их, можно создать подобие функционала `template`. Но в таком случае нам придется заранее знать, с какими конкретными типами будет работать класс или функция. Например, мы можем задать шаблон функции, но для каждого типа придется прописывать что-то вроде: 

- Если тип Т не определен - определить его как int и использовать шаблон. 

- Если тип Т не определен - определить его как double и использовать шаблон. 

Если… И так далее. ( Думаю можно не вникать в синтаксис, т.к. на чистом Си мы не пишем, но описанные здесь словами действия можно посмотреть в виде кода в этой [статье](https://habr.com/ru/post/154811/) )

То есть если мы хотим одинаковый рабочий код для 100 различных типов, нам придется явно это указать в коде. Конечно, мы не повторяем саму реализацию 100 раз, но мы указываем все 100 типов, с которыми хотим работать, а это не прикольно.

Я так понимаю, что директивы препроцессора и шаблоны - не абсолютно, но все же разные вещи, которые применяются для своих целей. Отвечая на вопросы, я бы сказал, что делают шаблоны (позволяют избежать повторов), а что делают директивы препроцессора (подготовка кода к компиляции, текстовая подмена кода). 

**Есть сомнение:**
Думаю, что этих представлений будет достаточно для ответа. Если есть что добавить - пишите что именно, а потом будем исправлять.

[//]: <> (/////////////////////////////////////////)
[//]: <> (Рустем: у меня нет здесь соображений, я ничего не знаю про дерективы препроцессора)
[//]: <> (/////////////////////////////////////////)

___
## Вопрос 77

**Правила перегрузки шаблонов: приведите короткие примеры.**
    
**Ответ:** 

Если мы хотим перегрузить шаблон, то достаточно создать еще одну версию шаблона, но уже с другим числом параметров. Рассмотрим пример:
```c++
template <class T>
void same(T s) {
    cout << s << endl;
}
template <class T, class Y>
void same(T s, Y e) {
    cout << s << e << endl;
}
```

Чтобы вызвать первый вариант, можно использовать просто `same(4)`. 
Но чтобы использовать вариант с перегруженным шаблоном, в данном случае подойдет вызов вроде `same(4, “what is it?”)`. 

**Внимание! Ниже приводится перегрузка обобщенной функции, а не перегрузка шаблона. Привожу это в пример, потому что кто знает, может оно тоже сюда.**

Можно использовать _явную специализацию_. Это версия обобщенной функции, когда вместо параметра типа мы подставляем конкретный тип. Это может быть полезно, когда наша обобщенная функция для всех типов работает одинаково, но, например, для `int` должна работать иначе (может для `int` есть более эффективная реализация). В таком случае сигнатура функции остается прежней, включая число и тип параметров, с одним небольшим изменением - параметризованный тип заменяется на конкретный.
Рассмотрим примеры:
```c++
template <class T> 
void swap(T &a, T &b) {
	T temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Общая реализация swap”;
}
void swap(int &a, int &b) {
	int temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Явная int специализация swap”;
}
template <> 
void swap<int>(int &a, int &b) {
	int temp;
	temp = a;
	a = b;
	b = temp;
	cout << “Явная int специализация swap (Этот вариант аналогичен способу выше, но является более современным. Разницы пока никакой, но с развитием языка она может появиться, в книжках рекомендуют именно этот вариант явной специализации)”;
}
```
Также мы можем перегружать обобщенные функции как и обычные - просто изменяя список параметров функции, оставляя сам шаблон неизменным.
___

## Вопрос 78

**Типизированные, нетипизированные и шаблонные параметры шаблонов - назначение и примеры использования.**
    
**Ответ:**     

Параметры шаблона могут быть: `типизированные`, `нетипизированные`, `шаблонные`.
На занятиях мы реализовывали структуры для последовательного хранения данных - `список`, `двусвязный список`, `стек`, `очередь`, `вектор` и тд. Предположим мы хотим сделать класс обертку, который бы мог быть и `списком`, и `вектором`, и `cтеком`, при этом зафиксировать максимальный размер этой структуры. Разумеется, сами структуры могли бы хранить данные любых типов. Как может выглядеть объявление такого класса? Например, так:
```c++
template <template<class> class L = Stack, class T = double, int size = 100>
class SomeData
{ 
  // do something... 
};
```
Что тут происходит?  Сначала мы объявляем шаблон для класса `SomeData`. У этого шаблона объявляем три параметра.

Первый параметр - _шаблонный параметр_. То есть параметр шаблона - это тоже шаблон. Объявляется он как `template<class> class L`. Написав так, мы ожидаем, что в этот параметр будет передан обобщенный класс, у которого всего один параметр типа шаблона. Например `стек`, который мы реализовывали:
```c++
template <class T>
class Stack : public LinkedList<T>
{
  // Stack body...
}
```
Тут видно, что в шаблоне используется только один параметр, поэтому мы можем использовать его. Если бы мы хотели использовать обобщенные классы с двумя и более параметрами типов, то использовали бы `template<class, class, ...> class L`. Иначе переменное число параметров типа в данном случае можно записаться как `template<class...> class L`
Что значит `= Stack`? Это значение по умолчанию, которое примет данный параметр, для примера указан `Stack`.
Дальше мы ждем _типизированный параметр_ шаблона, наш второй параметр. Ему так же можно дать значение по умолчанию, например `double`.
И последний, _нетипизированный параметр_ - в его роли могут выступать целочисленные константы (включая перечисления) или указатели на объекты с внешним связыванием. Чаще всего это все же целочисленная константа, как в нашем случае. Ей тоже можно присвоить значение по умолчанию, в нашем случае 100.
___
## Вопрос 79
**Чем может быть нетипизированный параметр шаблона?**
    
**Ответ:** 
Аргументы, которые передаются параметру, не являющемуся пользовательским типом, должны содержать либо **целочисленную константу**, либо **указатель или ссылку на глобальную функцию или объект**. Таким образом, эти _"нетиповые"_ параметры следует рассматривать как константы, поскольку их значения не могут быть изменены. И раз уж они константы, о них все известно уже на стадии компиляции.
**UPD**
**Вопрос by [Igetsuga](https://github.com/Igetsuga)**: Целочисленную?? Почему только int? И точно именно константу?
Да, именно целочисленную. int, short, byte, long... не только int. И да, только константа, т.к. память под нетипизированный параметр выделяется на стадии компиляции, а во время выполнения программы. Пример с константой в ответе на 83 вопрос.
[//]: <> (/////////////////////////////////////////)
[//]: <> (целочисленную?? почему только int? и точно именно константу??)
[//]: <> (/////////////////////////////////////////)
___
## Вопрос 80
**Всякое ли имя класса может быть передано в типизированный параметр шаблона?**
    
**Ответ:** 
Можно использовать любые имена, кроме зарезервированных, а также если имя параметра шаблона не совпадает с именем шаблона класса, именем функции и именем параметра функции. Также имена параметров шаблона, если их несколько, должны быть разными.
**Вот так делать НЕ НАДО**
```c++
// Зарезервированное имя
template <class bool>
class fail_bool {};
// Имя параметра шаблона совпадает с именем шаблона класса
template <class SomeName>
class SomeName {};
// Имя совпадает с именем функции
template <class fun>
void fun() {}
// Имя совпадает с именем парметра функции
template <class size>
void area(size a, int size) {}
// Имена параметров шаблона совпадают
template <class A, class A>
class some_class {};
```
## Вопрос 81
**Что может получиться из шаблона при подстановке в него всех типизированных и нетипизированных параметров?**
    
**Ответ:** 
Я, честно, не очень понимаю вопрос, но если здесь нужно ответить что-то вроде: шаблонный класс, шаблонная функция ИЛИ если имеется ввиду подстановка конкретных значений, то, наверное, получится конкретная реализация класса / метода. Если вы знаете что здесь нужно отвечать, напишите мне, буду крайне признателен.
**Мнение [Igetsuga](https://github.com/Igetsuga)**: Я думаю, что здесь про конкретную реализацию
___
[//]: <> (/////////////////////////////////////////)
[//]: <> (Я думаю, что здесь про конкретную реализацию)
[//]: <> (/////////////////////////////////////////)
## Вопрос 82
**Параметры по умолчанию в шаблонах и перегрузка шаблонов: правила задания и выбора используемого шаблона.**
**Ответ:** 
В шаблонах, как уже замечалось ранее, можно устанавливать значения по умолчанию, будь они `типизированные`, `нетипизированные`, `шаблонные`. Главное чтобы параметры со значением по умолчанию стояли последними в списке параметров. Если при использовании шаблона для них не указать значение явно, будет использоваться значение по умолчанию. 
Шаблоны, как и обычные классы - методы можно перегружать. Можем перегружать их, перегружая сам шаблон - изменяя количество параметров шаблона. А можем перегружать, изменяя список параметров, или приводя явную специализацию. Подробнее примеры перегрузок приведены в ответе на `77 вопрос`. 
Как компилятор понимает, какую версию шаблона использовать? Посмотрим на следующий код: 
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}
template <> 
void swap<int>(int &a, int &b) {
	cout << “Явная int специализация swap”;
}
template <> 
void swap<double>(double &a, double &b) {
	cout << “Явная double специализация swap”;
}
```
Если мы захотим вызвать `swap(4,2)`, то сначала будет проверяться, нет ли реализаций `swap` для `int` значений - более специализированного случая. Если такой не найден, будет вестись поиск более общего случая, и так далее, пока не найдется подходящая структура. Если бы мы хотели использовать `double` реализацию, имея все те же числа 4 и 2, мы бы явно указали это так: `swap<double>(4, 2)`.

___

## Вопрос 83

**Шаблоны классов: назначение, определение, применение и правила порождения объектов.**

**Ответ:** 

Шаблоны можно применять к классам, тогда классы становятся `обобщенными`. Еще обобщенный класс называется `шаблоном класса`.

Применяется это, как и для функций - чтобы выделить общий код, который одинаково работает с разными типами.
Например мы хотим создать свой класс - список для хранения данных. Также мы не хотим ограничиваться каким-то определенным типом данных. Вместо того, чтобы переписывать один и тот же функционал для списка под тип данных `int`, `long`, `double`, `Student`, `Car`, `State`...мы добавляем к классу шаблон - точно так же, как и для функции. 

Например, знакомый класс `vector`. Как породить объект этого класса? Синтаксис уже знаком:
```c++
vector<int> v;
```
Где на месте `int` может стоять любой тип данных. В общем виде, после имени класса, в угловых скобках нужно определить тип параметров шаблона для класса.

Какие правила при порождении? Для класса обязательно указывать типы, с которыми работает класс в угловых скобках, без этого программа не знает, с какими данными ей работать. Ну еще это обязательно должен быть тип данных, примитивный или пользовательский, мы не можем передать в параметр шаблона ссылку на функцию. **Также в угловых скобках обязательно передавать константу**.

**UPD**

**Вопрос by [Igetsuga](https://github.com/Igetsuga)**: Не понял про константу. Привиди, пожалуйста, пример

В случае с `типизированными` параметрами мы указываем в угловых скобках используемый тип, это константа. В случа `шаблонных` параметров, тут мы тоже передаем просто тип, это тоже константа. Код ниже не скомпилирутся, в случае `нетипизированных` параметров значение `x` тоже должно быть константой:
```c++
template <short T>
class question
{
    // some useless code
};
int main()
{
    int x = 34;
    question<x> example;
}
```

[//]: <> (/////////////////////////////////////////)
[//]: <> (Не понял про константу. Привиди, пожалуйста, пример)
[//]: <> (/////////////////////////////////////////)

___

## Вопрос 84

**Способы порождения функций и классов из шаблонов. Приведите короткие примеры.**
    
**Ответ:** 

Рассмотрим порождение **функции**: 
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}
```
Можем использовать ее, явно не указывая, с каким типом работает функция, в таком случае тип определяется автоматически по типу аргументов функции:
`swap(3.1, 5.23);`

Можем указать тип параметра шаблона явно, используя угловые скобки:
`swap<int>(3, 45);`

Порождение `класса` всегда сопровождается указанием типа в угловых скобках, за исключением случаев, когда предусмотрены значения по умолчанию:
```c++
vector<int> v;
```
Если память выделяется _динамически_, то объявление выглядит так:
```c++
vector<int>* v = new vector<int>();
```
Обратить здесь нужно внимание на то, что угловые скобки используются повторно. Также важно заметить, что указывать тип в обеих скобках обязательно - причем он должен строго совпадать.
___

## Вопрос 85

**Уточнение (спецификация, перегрузка) шаблонов: назначение, выяснение, какой шаблон будет в каком случае использован.**
    
**Ответ:** 

Виды и примеры спецификации (явной специализации) приведены в ответе на 77 вопрос. Шаблоны одинаково перегружаются для методов и классов, поэтому этих примеров будет достаточно для понимания. 

Зачем это нужно?

В случае со спецификацией - применяется в основном, если мы хотим отойти от шаблонного кода для какого-то определенного типа (это может быть связано с наличием более эффективного решения для данного типа).

В случае с перегрузкой - используется точно в тех же случаях, когда нам в принципе нужна перегрузка, когда нам нужно поменять параметры, но функционал остается тем же. Только тут еще используются шаблоны.

Рассмотрим пример:
```c++
template <class T> 
void swap(T &a, T &b) {
	cout << “Общая реализация swap”;
}
void swap(int &a, int &b) {
	cout << “Явная int специализация swap”;
}
```
Хотим вызвать `swap(2.2, 4.21)`. Сначала ищется вариант с более конкретными параметрами - ищется метод `swap`, принимающий два `double`. Если таких не было найдено, то ищется более общий случай - шаблонный. Вот здесь он найдет нужный вариант и отработает по нему. Грубо говоря, когда идет поиск нужного варианта, программа движется вверх по иерархии - от более специализированного, до более общего случая. 

___

## Вопрос 86

**Как меняются правила перегрузки функции при появлении шаблона функции?**
    
**Ответ:** 

Да, в общем то, никак. У функции главное поменять набор параметров или их тип, тогда она и будет перегружена.

Для обобщенных функций главное помнить, что у них есть перегрузка в виде изменеий параметров, а есть специализация, которая была рассмотрена в ответе на 77 вопрос.

Также можно перегружать сами шаблоны, изменяя число параметров шаблона или их тип. Пару примеров:
```c++
// обобщенная функция
template <class T> 
T bor(T a) {
	cout << "T bor\n";
    return a;
}
// ее специализация
template<>
int bor<int>(int a) {
	cout << "int bor\n";
    return a;
}
// изменение параметров + типа возвращаемого значения
template <class T>
void bor(T a, double d) {
	cout << "void bor\n";
}
// используем нетипизированный параметр вместо типизированного
template <int n>
int bor(int a) {
	cout << "non-type bor\n";
    return a;
}
```
___

## Вопрос 87

**Средства динамического выделения/освобождения памяти и их отличие от конструктора и деструктора.**
    
**Ответ:** 

Когда используются _конструкторы_ или _деструкторы_, мы работаем с `статической областью памяти`, иначе - со `стеком`. В этом случае программа заранее знает, сколько места нужно выделить под объекты и уже на стадии компиляции выделяет для них память, а также очень просто удаляет из этой же памяти, когда программа прекращает свою работу.

В случае с _динамическим выделением памяти_ `(new)` и _динамического освобождения памяти_ `(delete)`, мы запрашиваем место у оперативной памяти, которая располагается вне нашей программы.

По сути главные отличия следующие:
+ динамическое выделение/особождение памяти - работа с оперативной памятью, а конструкторы и деструкторы работают со статической памятью. 
+ используя `new` мы получаем _указатель_ на объект, а не сам объект, как в случае с конструктором
+ деструктор сработает автоматически по завершении программы, но в случае с динамическим освобождением памяти, нам необходимо самостоятельно заботиться о запрошенной памяти, поэтому мы сами должны вызвать `delete`, после того как память нам больше не нужна, иначе может произойти _утечка памяти_. По завершении программы оперативная память все равно очистит весь мусор, но если мы увлечемся, то программа может аварийно завершится, а это явно не то, что нам нужно.
+ **UPD by [Igetsuga](https://github.com/Igetsuga)**: Конструктор может быть вызван неявно, а оператор `new` всегда вызывается явно.
___

[//]: <> (/////////////////////////////////////////)
[//]: <> (Но в самом конструкторе тоже может быть динимическое выделение памяти. Поэтому конструктор тоже может выделять пямять в куче Run-time. Мне кажется, что 2,3 пункты здесь самые важные. Еще можно добавить про то, что конструктор может быть вызван неявно, а оператор `new` неявно не может быть вызван.)
[//]: <> (/////////////////////////////////////////)

## Вопрос 88

**Стандартные средства динамического выделения / освобождения памяти и наследование: что будет использовано, если имеется перегрузка new / delete в базовом / порождённом классе?**
    
**Ответ:** 

Возможно тут все как в обычном наследовании.

~~Отвечу на этот вопрос позже, когда разоберусь, как устроена перегрузка `new` и `delete`. Вероятно тут есть подводные камни.~~

**Upd:**

Да, здесь все как в обычном наследовании. Если реализация в родителе - о ней знает и наследник. Если реализация в наследнике - родитель о ней ничего не знает.

___

## Вопрос 89

**Пространства имён: определение, использование, наименование, вложенность.**
    
**Ответ:** 

Пространства имен - это, по сути, граница, оболочка для кода, у которой есть название. Можно представить ее как папку в файловой системе, в которой лежат файлы нашего кода. Но, конечно, это просто аналогия. Зачем они нужны? Представьте два человека, которые никогда не общались друг с другом, пишут программу (ну вот так). Каждый реализовывает свой функционал, но что если названия, например, функций где-то совпадут? Тогда им нужно заговорить друг с другом (а они этого не хотят) и договориться о новых именах. А если такое происходит регулярно? Вот в такие моменты поможет использование пространства имен. Мы обертываем код внутри пространства имен, и теперь можем обращаться к нашему коду через название его пространства имен, что позволяет избежать неоднозначность. Мы точно будем знать, чей код используем: Васи или Пети. Посмотрим на код ниже: 
```c++
namespace Vasya
{
    class Stack
    {
    public:
        int t;
        void print()
        {
            t = 1000000;
            cout << t << " amazing cats!\n";
        }
    };
    template <class T>
    class Madara
    {
    public:
        T raz;
        void haha()
        {
            cout << "haha stupid naruto, using\n" << raz;
        }
    };
    int foo() {
        return 4;
    }
    int foo(int x) {
        return x + 3;
    }
    double it_is_euler_number_yes_it_is_not_pi = 3.14;
}
```
Что? Объявлено пространство имен с названием `Vasya`, для этого было использовано `namespace Vasya {...}`. Название может быть любым, не зарезервированным `с++`. Внутри пространства имен могут располагаться переменные, функции, классы...или другие пространства имен. В общем-то, это что-то вроде оболочки для ваших классов, функций и переменных. На них не накладываются никакие новые ограничения. Теперь, если бы у Пети был точно такой же код, но с другой реализацией, мы бы могли разрешить неоднозначность, в этом нам и помогли пространства имен. Как это разрешение реализуется? Использованием оператора разрешения области видимости `::` c  указанием названия пространства имен перед используемыми функциями, классами, переменными. Выглядит это так:
```c++
int main()
{
    Vasya::foo();
    Vasya::Madara<int> madara();
    double euler_yes = Vasya::it_is_euler_number_yes_it_is_not_pi;
}
```
Перед использованием чего-либо, мы сначала указываем название пространства имен, из которого хотим взять нужное что-то, а затем ставим `::`, после чего само что-то. Вот так все просто. А. Еще внутри пространства имен можно указать еще одно пространство имен, которое будет вложенным. Тогда, обращаясь к коду, мы должны указать через двоеточие всю цепочку вложенности. Например: 
```c++
namespace first {
    namespace second {
        void foo() {
            cout << "hello, have you a good day";
        }
    }
}
int main()
{
    first::second::foo();
}
```

Пожалуй здесь скажу еще об одной возможности. Если мы уверены, что код внутри пространства имен никак не будет конфликтовать с нашим кодом через имена переменных, функций и тд, то можно избавить себя от постоянного упоминания `Vasya::some_code`, и использовать `using namespace Vasya`. В таком случае весь код, который располагался в `namespace Vasya` будто бы встроится в наш код, как в родной, и мы будем иметь возможность обращаться к нему так же, как если бы сами его написали у себя в программе. Мы уже использовали это, например `using namespace std` дает нам возмодность использовать переменные и функции из пространства имен std.

___

## Вопрос 90

**Как сделать, чтобы в некотором блоке использовать несколько пространств имён сразу? Каким требованиям они должны отвечать?**
    
**Ответ:** 

Рассмотрим пример:

```c++
namespace first {
    namespace second {
        void foo() {
            cout << "hello, have you a good day";
        }
    }
    namespace second {
        // Будет вызвана ошибка, удалите этот код, если хотите запустить пример
        void foo() {
            cout << "Error, foo is already exists";
        }
        void hiheha() {
            cout << "hihi hehe haha";
        }
    }
    namespace third {
        void x() {
            cout << "i found x! x is:  " << 5 << endl;
        }
    }
}
int main()
{
    first::second::foo();
    first::second::hiheha();
    first::third::x();
}
```

Несколько пространств имен в одном блоке использовать _можно_. Какие требования? Если мы хотим чтобы они были разные, то имена у них должны быть разными. Что значит, что мы два раза объявили `second`? По сути это то же самое, как если бы мы объявили его один раз, и весь код находился в одном месте. Проще говоря, можно было написать так, это было бы **одно и то же**:
```c++
//...
namespace second {
        void foo() {
            cout << "hello, have you a good day";
        }
        // Будет вызвана ошибка, потому что это объявление одно и того же дважды
        void foo() {
            cout << "Error, foo is already exists";
        }
        void hiheha() {
            cout << "hihi hehe haha";
        }
    }
//...
```
Думаю, что здесь больше не о чем говорить, в одном блоке можно использовать разные пространства имен, кроме вышеописанной особенности я больше никаких не знаю. Делать ничего особенного не нунжно.

___

## Вопрос 91
 
**Могут ли в одном классе быть несколько пространств имён?**
    
**Ответ:**

Внутри класса пространства имен не объявляются. Если имеется в виду файл с кодом, то да, могут.

___

## Вопрос 92

**Могут ли в одном пространстве имён быть несколько классов?**
    
**Ответ:**

Да, могут. Ничего не мешает это сделать (см ответ на 89 вопрос).

___

## Вопрос 93

**Могут ли два пространства имён пересекаться (но не одно не содержится в другом)?**
    
**Ответ:**

Что значит пересекаться? Если имеется ввиду, `могут ли они иметь одинаковые функции, классы и тд`, то да, могут, мы ведь используем их через абсолютный путь. 

Если имеется ввиду: `можем ли мы обращаться к одному пространству имен из другого, если они не являются вложенными`, то да, можем. Например через абсолютный путь, или же внутри `namespace` использовать `using namespace other_namepace_name`. Здесь главное позаботиться о том, чтобы не возникало неоднозначности, какой класс, функцию, какую переменную использовать. Как это разрешается - см ответ на 89 вопрос.

# Вопросы 94-99

Некторое предисловие.

Язык программирования называется **строго типизированным**, если в нем разрешены только явные преобразования типов. Т.е. язык программирование не разрешает смешивать сущности разных типов в выражениях и не выполняют никаких автоматических преобразований.

С++ не является строго типизированным языком программирования, поэтому когда вы пишите программу, вы должны убедиться, что она является строго типизированной и это очень важно. Почему ваши программа дожна быть строго типизированной? Зачем нужна строгая типизация?
- Надежность — Вы получите исключение или ошибку компиляции, взамен неправильного поведения.
- Скорость — вместо скрытых(неявных) преобразований, которые могут быть довольно затратными, с сильной типизацией необходимо писать их явно, что заставляет программиста как минимум знать, что этот участок кода может быть медленным.
- Понимание работы программы — опять-же, вместо неявного приведения типов, программист пишет все сам, а значит примерно понимает, что сравнение строки и числа происходит не само-собой и не по-волшебству.
- Определенность — когда вы пишете преобразования вручную вы точно знаете, что вы преобразуете и во что. Также вы всегда будете понимать, что такие преобразования могут привести к потере точности и к неверным результатам.


## Вопрос 94

**Неявные преобразования типа в C++: перечислите, приведите короткие примеры**

**Ответ:** 

Преобразование типа называется **неявным**, если его совершает компилятор без участия программиста.

Когда происходит неявное преобразование типов:
- после вычисления операндов бинарных арифметических, логических, битовых операций, операций сравнения;
- перед выполнением присваивания;
- перед передачей аргумента функции;
- перед возвратом функцией возвращаемого значения;
- после вычисления выражения конструкции `switch` значение приводится к целочисленному типу;
- после вычисления выражений конструкций `if`, `for`, `while`, `do-while` значение приводится к типу `bool`;
- конструкторы преобразования (если он не объявлен с ключевым словом `explicit`)

Примеры:
```c++
int xn = 1;
double xd = 1.05;
if ( xn < xd ) { return 0; }
// 1. xn(int) -> xn(double)
// 2. сравнение
// 3. приведение результата операции сравнения к типу `bool`
int xx = xn + xd;
// 1. xn(int) -> xn(double)
// 2. xn + xd 
// 3. приведение результата сложение к типу `int`
void foo (double x) {
    std::cout << "yoo" << '\n';
}
foo (xd)
// 1. xn(int) -> xn(double)
// Конструктор преобразования
class A {
public:
    // default constructor
    A() = default;
    // default destructor
    ~A() = default; 
    // converted constructor
    A (B object) {
        ...
    }
    // converted constructor
    A (int variable) {
        ...
    }    
}
```

Причем стоить отметить, что в арифметическим операциях с типами разных размеров тип с меньшим размером расширяется(продвигается) в больший тип. Т.е. в наших примерах тип `int` (4 байта) расширется в `double` (8 байт)

## Вопрос 95

**Явные преобразования типа в C++: встроенные формы const_cast, static_cast, dynamic_cast, reinterpret_cast. Правила выбора типа преобразования.**

**Ответ:** 

Преобразование типа называется явным, если это преобразование справоцировано самим программистом. 

1. Сначала дополним ответ на предыдущий вопрос.  
    Конструктор преоброзований, объявленный с ключевым словом `explicit`, можно считать явным конструктором преобразований. Это ключевое слово запрещает компилятору самому вызывать этот конструктор там, где он мог бы это сделать, например, в строке 39. 
    ```c++
    class Complex {
    public:
        
        Complex() = default;
        Complex(double Re, double Im) {
            _Re = Re;
            _Im = Im;
        }
        ~Complex() = default;
        explicit Complex (double Re) { // строка 16
            _Re = Re; 
            _Im = 0;
        }
        friend void _print(const Complex &complex);
    private:
        double _Re;
        double _Im;
    };
    void _print(const Complex &complex) {
            std::cout << '\n' << "Re = " << complex._Re;
            std::cout << '\n' << "Im = " << complex._Im;
    }
    int main() {
        Complex z(23.1, 0.42); _print(z);
        Complex zn(2.0); _print(zn);  // строка 37
        double xn = 1.42; _print(xn); // строка 39
        return 0;
    }
    ```
2. `static_cast`  
   Этот преобразователь можно желательно применять только для типов, которые заранее известны компилятору, т.к. проверка проверка приведения выполняется только во время компиляции, когда компилятор не знает о конструкторах преобразования ваших типов. 
   ```c++
    double d = 1.58947;
    
    // неявное пребразование типов, возможна потеря данных, пользователь об этом не знает
    int i = d;  // warning C4244 possible loss of data
    
    // явное пребразование типов, поторя данных, но пользователь об этом знает
    int j = static_cast<int>(d);       // No warning.
    
    // компилятор не умеет преобразовывать `double` в `std::sring` 
    string s = static_cast<string>(d); // Error C2440:cannot convert from
                                    // double to std:string
    // No error but not necessarily safe.
    Base* b = new Base();
    Derived* d2 = static_cast<Derived*>(b);
   
   ```

3. `dynamic_cast`  
   Этот оператор приведения выполняет безопасное приведение указателя базового класса на указатель типа производного класса. В этом случае проверка приведение возложена на среду разработки(что отрицательно сказывается на эффективности) и выполняется во время работы программы.
   ```c++
    Base* b = new Base();
    // Проверка во время выполнения, действительно ли указатель b имеет тип `Derived*`
    Derived* d3 = dynamic_cast<Derived*>(b);
    // Если предыдущее действие выполнено(b является указателем типа...,) значит, теперь d3 допустимый указатель
    if(d3) {
    // можно безопасно вызвать метод класса `Derived`
    cout << d3->DoSomething() << '\n';
    }
    else {
    cout << "d3 is null" << '\n';
    }
    // Output: d3 is null;
   ```

    Обратите внимание, что в предыдущей программе не произошло преобразование из типа `Base*` в тип `Derived*`, т.к. такое преобразование возможно только в обратную сторону: из базового в производный.
4. `const_cast`  
   Для преобразований:
   - Type -> const Type
   - const Type -> Type
   ```c++
    void func(double& d) { ... } {
    const double pi = 3.14;
    func( const_cast<double&>(pi) ); // No error.
    }
   ```
5. `reinterpret_cast` 
    
    [В чем смыслre interpret_cast?](https://ru.stackoverflow.com/questions/716240/%D0%92-%D1%87%D1%91%D0%BC-%D1%81%D0%BC%D1%8B%D1%81%D0%BB-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-reinterpret-cast)

    Этот указатель используется для приведения между несвязанными типами, например, `Type*` и `double` или, как в примере, `std::string` в тип `int`
    ```c++
    const char* str = "hello";
    int i = static_cast<int>(str); // error C2440: 'static_cast' : cannot
                    // convert from 'const char*' to 'int'
    int k = reinterpret_cast<int>(str); // Programming intent is clear. // However, it is not 64-bit safe.
    ```

## Вопрос 96

**Функциональная форма преобразования типа в c++. Её реализация.**

**Ответ:** 

Два устравших стиля, которые эквивалентны из-за оптимизаций компилятора, не нужно их использовать: 
- си-подобный 
- функциональный
```c++
double x = 10.3;
int y;
y = int (x);    // преобразование в функциональном стиле
y = (int) x;    // преобразование в стиле Си
//  в таких простых случаях лучше подходит оператор `static_cast`
```

## Вопрос 97

**Что требуется сделать, чтобы можно было использовать функциональную запись преобразования из класса A в класс B?**

**Ответ:** 

Если хотя бы один из типов приведения не является стандарным, то необходимо написать соответствующий конструктор преобразования, в других случаях компилятор сделает за вас всю работу 

## Вопрос 98

**Какие преобразования типа принимаются в расчёт только во время компиляции?**

**Ответ:** 

| Тип преобразования                  | Время исполнения |
|-------------------------------------|------------------|
| любое неявное преобразование        | Run-time         |
| explicit конструктор преобразования | Run-time         |
| static_cast                         | Compile-time*    |
| dynamic_cast                        | Run-time         |
| const_cast                          | ??               |
| reinterpret_cast                    | ??               |
| си-подобное преобразование          | Compile-time     |
| функциональное преобразование       | Compile-time     |

## Вопрос 98

**Преобразования указателей и ссылок в C++: особенности с учётом наследования.**

**Ответ:** 

Мне кажется, что здесь спрашивается про виртуальные деструкторы(кстати, конструкторы не могут быть виртуальными, подумайте почему).

Схема наследование в примере. LinkedList <-- Stack
```c++
    LinkedList<Programmer>* ptr_base = new LinkedList<Programmer>();
    // указателю ptr_base доступны методы только базового класса
    
    // при удалении указателя на базовый класс, который смотрит на экземпляр базового класса, должен быть вызван
    // деструктор базового класса. (ВЫПОЛНЕНО)
    delete ptr_base;
    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    Stack<Programmer> derived_stack;
    ptr_base = &derived_stack;
    // при удалении указателя на базовый класс, который смотрит на экземпляр производного класса сначала должен быть вызван
    // деструктор производного класса, потом деструктор базового, но это произойдет только в случае, если деструктор базового 
    // класса объявлен виртуальным. Иначе с самого начала будет вызван деструктор базового класса, а деструктор производного
    // класс не будет вызван. Произойдет утечка памяти, если под атрибуты производного класса была выделена память. (ВЫПОЛНЕНО)
    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    Stack<Programmer>* ptr_derevid = dynamic_cast<Stack<Programmer>*>(ptr_base); 
    // указатель ptr_derived смотрит на объект derived_stack.
  
    // поскольку указатель на производный класс смотрит на объект свого класс, то деструкторы должны быть вызваны 
    // в порядке наследования, т.е. сначала деструктор производного класса, потом деструктор базового класса. (ВЫПОЛНЕНО)
```

# Вопросы 100-107

**Объявление** - выделение памяти под объект.  
За объявление отвечают аллокаторы(не совсем точная инфа, ведь есть и другие штучки, отвечающие за выделение памяти)


**Присваивание** - задание значений для полей объекта.  
За присваивание отвечает `operator=`

**Инициализация** - объявление + присваивание одновременно.  
За инициализацию отвечают конструкторы.

___
## Вопрос 100

**Инициализация объектов классов, перечислите все её способы и проиллюстрируйте примерами.**

> [Инициализация в C++](https://hsto.org/r/w1560/webt/bp/rd/ow/bprdow1rk6jtw5fzpm3bffzirps.gif)
**Ответ:** для начала отметим, что тема инициализации в c++ очень глубока и сложна, каждый стандарт содержал дополнения, но тем не менее все еще ведется разработка. Если хотите супер подробно, и  если вам не жалко для этого пары часов, то читайте эту [интересную статью](https://habr.com/ru/company/jugru/blog/469465/). Начнем инциализаций, которые перекочевали в C++ из C.

1.  **Инициализация по умолчанию**
    
    На самом деле это неудачное название для этого вида инициализации, ведь, честно говоря, это даже не совсем инициализация, а больше похоже на объявление. Пример 1
    ```c++
    class Human {
    public:
        int _age;
        int _chromosomes;
    };
    int main() {
        Human chel;
        return chel._age; // неопределенное поведение
    }
    ```
    Мы здесь успользовали вместо `struct` - `class`, а этого вообще-то не было в C, но не будем на этом заострять внимание, просто мы так захотели. Упомянем здесь еще две инициализации. Первая - `member initializer list`, что была добавлена в C++98, вторая - `default member initializers`, что была добавлена в C++11. 
    
    >Пример 2. (Но такое решение проблемы не оптимальное, поскольку это необходимо делать в каждом конструкторе, и об этом легко забыть. Кроме того, инициализация идёт в порядке, в котором переменные объявлены, а не в порядке member initializer list)
     ```c++
    class Human {
    public:
        Human() : age(20), chromosomes(48) {} // member initialiser list
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_;
        int _chromosomes_;
    };
    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >Пример 3. (Позволет инициализировать все переменные одновременно, и это даёт уверенность, что все элементы инициализированы)
    ```c++
        class Human {
    public:
        const int get_age() const noexcept { return _age_; }
        const int get_chromosomes() const noexcept { return _chromosomes_; }
    
    private:
        int _age_ = 20;         // default member initialisers
        int _chromosomes_ = 48; // default member initialisers
    };
    int main() {
        Human chel;
        return chel.get_age(); // Вывод: 20
    }
    ```
    >(Хабр) Рекомендация: когда можете, всегда используйте DMI (default member initializers).
2. **Копирующая инициализация**
    ```c++
    int variable = 42;
    ```

    В этом случае мы указываем переменную и через знак равенства — её значение. Отметим, что копирующая инициализация также используется, когда аргумент передаётся в функцию по значению, или когда происходит возврат объекта из функции по значению. Мы смотрим на знак равенсва и думаем: "Так это же присвоение значения...". Оказывается, что нет. **Копирующая инициализация — это не присвоение значения. Оператор присваяивания здесь нечего не делает!**
    
3. **Агрегатная инициализация**

    Используется для массивов и агрегатных классов (_т.е. набор публичных полей, объединеных в `class`_). 
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }
        int _age;
        int _chromosomes;
    };
    int main() {
        Human chel {20, 48};   // <=> Human chel = {20, 48};
        std::cout << chel.get_age() << '\n'; // Вывод: 20
        Human chuvak {20}; // остальные значения инициализируются 0
        std::cout << chel.get_chromosomes() << '\n' // Вывод: 0
    }
    ```
    >Агрегатная инициализация на самом деле использует копирующую инициализацию для каждого элемента.
4. **Статическая инициализация**
    
    Шанс, что у вас про это спросят стремится к 0, но для умников и умничек, мы не забили на него. Суть статической инициализации в том, чтобы инициализироавть статический объект (_для этого объекта ппамять выделяется только 1 раз, а существует он на протяжении работы всей программы_) на стадии компиляции (не знаю примера, зачем это нужно).
    
    ```c++
    class Human {
    public:
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }
        int _age;
        int _chromosomes;
    };
    int main() {
        static Human chel { 20, 48 };   // <=> Human chel = {20, 48};
        
        std::cout << chel.get_age() << '\n'; // Вывод: 20
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 48
    }
    ```

    Здесь стоит быть аккуратным, поскольку если где-то еще появляется статический объектр, который использует `chel`, возникнет проблема, что первое из них инициализировать, на самом деле это решается через `constexpr`, но мы об этом ничего не знаем, а поскольку ответ на первый вопрос мы пишем уже 3 часай, то разбираться в этом сил нет.

5. **Прямая инициализация**
    
    > До этого момента мы ни разу не использовали конструкторы, потому что все предыдущие инициализации пришли из C, где конструкторов не было.
    Прямая инициализация для базовых типов это абсолютно то же самое, что и копирующая инициализация. Но для пользовательских типов при копирующей инициализации мы не могли сразу инициализировать несоколько атрибутов, а здесь мы можем передать несколько значей, поэтому можем инициализировать несколько полей. Но это не все отличия, чтобы узнать остальные читай [статью](https://habr.com/ru/company/jugru/blog/469465/)

    Пример 4
    ```c++
    class Human {
    public:
        explicit Human (int age = 20, int chromosomes = 48) { // 3 строка
        _age = age;
        _chromosomes = chromosomes;
        };
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }
        int _age;
        int _chromosomes;
    };
    int main() {
        static Human chel { 8, 47 };   // Вызов конструктора из 3 строки;
        
        std::cout << chel.get_age() << '\n'; // Вывод: 8
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 47
    } 
    ```
    > Кстати скобки `()`, возможно с параметрами, при инциализации всегда вызывают конструктор.
6. [**Инициализация значением**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%B8%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B3%D0%BE%20%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F.-,%D0%98%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC%20(C%2B%2B03),-%D0%9F%D0%B5%D1%80%D0%B5%D0%B9%D0%B4%D1%91%D0%BC%20%D0%BA%20%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D1%8E%D1%89%D0%B5%D0%B9)

   **Правило такое: если существует определённый пользователем конструктор по умолчанию, инициализация значением вызывает этот конструктор, в противном случае возвращается нуль.**

7. [**Универсальная инициализация (C++11)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%3D%20default.-,%D0%A3%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20(C%2B%2B11),-%D0%92%20%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B8%20%D0%A1)

8. [**Назначенная инициализация (С++20)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D1%83%D0%BB%D1%83%D1%87%D1%88%D0%B8%D1%82%D1%8C.-,%D0%9D%D0%B0%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20(%D0%A1%2B%2B20),-%D0%A2%D0%B5%D0%BF%D0%B5%D1%80%D1%8C%20%D0%B4%D0%B0%D0%B2%D0%B0%D0%B9%D1%82%D0%B5%20%D0%BF%D0%BE%D0%B3%D0%BE%D0%B2%D0%BE%D1%80%D0%B8%D0%BC)

9. [**Прямая инициализация агрегатных типов (C++20)**](https://habr.com/ru/company/jugru/blog/469465/#:~:text=%D0%B4%D0%BB%D1%8F%20%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B0.-,%D0%9F%D1%80%D1%8F%D0%BC%D0%B0%D1%8F%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%B0%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%82%D0%BD%D1%8B%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20(C%2B%2B20),-%D0%9D%D0%B0%D0%BA%D0%BE%D0%BD%D0%B5%D1%86%2C%20%D0%B2%20%D0%A1) 
___

## Вопрос 101

**Что нужно сделать, чтобы имелась возможность инициализировать значение объекта в месте его определения?**
    
**Ответ:** 

мне кажется, что ждут ответ типа: "если мы говорим про пользовательские классы, то - написать соответсвующий конструктор". Но вы посмотрите на первые 4 пункта из вопроса 100, там нигде явный конструктор не нужен был, компилятор сам создавал свой конструктор для этого. 
> На самом деле, если мы не написали **никакой** конструктор для `struct`, `class`, `union`, то компилятор всегда сможет сделать это сам, при этом запихнет он его в публичнй раздел нашей структуры. См. [здесь](https://en.cppreference.com/w/cpp/language/default_constructor#:~:text=If%20no%20user,of%20its%20class.)
Поэтому мы бы ответили, что "ничего, ибо компилятор позволит нам это сделать".
___

## Вопрос 102

**Можно ли проинициализировать значение объекта в месте его определения без вызова конструктора?**

В месте его объявления без конструктора - нет. Конструктор будет вызван неявно.

Не в месте его объявления - да. С помощью инициализатора.

Пример. Инициализатор - `Point::SetValue()`
```cpp
#define nline '\n'
#include <iostream>
class Point {
public:
    void SetPosition (const double &x = 0, const double &y = 0) noexcept {
        _x = x;
        _y = y;
    }
    void GetPosition() const noexcept {
        std::cout << nline << "(" << _x << "," << _y << ")" << nline;
    }
private:
    double _x;
    double _y;
};
int main()
{
    Point point; point.SetPosition(2, 89); 
    
    point.GetPosition();
    return 0;
}
```

**Замечание.** Поскольку нет конструктора по имолчанию и инициализации по умолчанию для класса не определена, то должно была возникнуть ошибка `UB`, но этого не произошло. Почему ошибки нет?  Потому что класс `Point` не имеет никаких сложных атрибутов, а инициализация по умолчанию определена для типа `double`. Будьте аккуратны, ведь инициализация по умолчанию доступна не во всех страндартах.

___

## Вопрос 103

**Инициализирующий конструктор: назначение, способ оформления, способы применения, отличие от перегрузки операции присваивания.**
    
**Ответ:**  
- **Инициализирующий конструктор** - любой ранее перечисленный конструктор. 
- Способ оформления. Конструктор - функция-член и её название обязательно должно совпадать с названием класса. Параметры конструктора могут отсутствовать, и тогда такой конструктор называется конструктором по умолчанию (= инициализация по умолчанию) (_default constructor_). А может содержать какие-то параметры, которые будут как-то учитываться при создани экземпляров структуры.
- Способ применения. Он вызывается автоматически при создании экземпляра структуры. Но конструктор объекта можно вызвать почти явно. С помощью оператора `new`, который сначала выделит память, а потом вызовет соответствующий параметрам конструктор.
- КОНСТРУКТОР != ОПЕРАТОР ПРИСВАИВАНИЯ. Пример
    ```c++
    class Human {
    public:
        explicit Human (int age = 20, int chromosomes = 48) {
            _age = age;
            _chromosomes = chromosomes;
        }
        explicit Human (const Human& other) {
            _age = other._age;
            _chromosomes = other._chromosomes;
        }
        Human& operator= (const Human& other) {
            _age = other._age;
            _chromosomes = other._chromosomes;
        }
        const int get_age() const noexcept { return _age; }
        const int get_chromosomes() const noexcept { return _chromosomes; }
        int _age;
        int _chromosomes;
    };
    int main() {
        Human chel(8, 47);   // <=> Human chel = {20, 48};
        Human chuvak = chel; // строка 32
        std::cout << chel.get_age() << '\n'; // Вывод: 20
        std::cout << chel.get_chromosomes() << '\n'; // Вывод: 48
    }
    ```

    В строке 32 будет вызван конструктор копий, даже если он не опрделен и НИКОГДА оператор присваиавния. 
    - Конструктор нужен, чтобы инициализировать поля структуры, т.е. раньше их не было, после появились
    - Оператов присваивания нужен для того, чтобы присвоить уже существующим полям одного объекта значения другого объекта.

___

## Вопрос 104

**Понятие ссылки: назначение, способы применения, побочные эффекты.**
    
**Ответ:** 

> Достаточно традиционный взгляд — это считать ссылку «замаскированным» константным указателем. Но Страуструп и другие авторы, например Стефан Дьюхэрст, считают такую точку зрения неверной и настаивают, что ссылка — это просто псевдоним переменой, на которую она ссылается.
Указатель, в свою очередь, это некий объект, значением которого является адресс в памяти другого объекта. 

> Синтаксис языка не позволяет различить целевой объект и саму  ссылку — все операции над ссылкой на самом деле являются операциями над объектом. Как следствие этого:  
>   1. Ссылку нельзя переназначить на другой объект - связь между ссылкой и переменной «до гробовой доски»
>   2. Нельзя сравнить адрес, содержащийся в ссылке, с адресом другого объекта или NULL
> Из этих свойств в свою очередь следуют другие ограничения:
> 
>    3. Ссылка должна быть инициализирована при создании (поскольку инициализировать ее позже не возможно)
>    4. Ссылка не может содержать нулевой адрес (поскольку проверить и обработать это невозможно)
В C++ есть потребность в _чистых указателях_ - указатели, для которых система типов гарантирует, что они инициализированны и не они не `nullptr` или `NULL`, свойства 3, 4 как раз организуют чистые указатели, эти же свойства есть главное достоинство ссылок.

1. **Назначение**
        
    Ссылки были созданы для того, чтобы где-то упросить работу с указателями и для того, чтобы служить `l-value` значениями при возврате их из функций. Указатели с последним не справляются, вот пример:
    ```c++
    int* foo(int* x) {
        return x;
    }
    int main() {
        int x = 42;
        int* ptr = &x;
        foo(ptr) = 7; // строка 12
    }
    ``` 

    Значение функции `foo(int*)` не является левосторонним значением, в строке 12 ошибка. В качестве еще одного примера можно привести `operator[]`, если бы он был реализован через указатели, у нас никогда бы не получилось следующее:
    ```c++
    int main() {
        std::vector<int> vector(42, 0);
        int array [42];
        
        vector[2] = 42;  // это не получилось бы 
        array[2] = 42;   // это не получилось бы
        std::cout << array[2] << '\n' << vector[2]; 
        
        return 0;
    }
    ```
    Вывод:
        
        42
        42

    На самом деле ради последнего и создали новый **тип**, который назвали ссылочным - ссылками. 

2. **Способы применения**
    
    инициализируете ссылку -> используете ссылку

3. **Побочные эффекты**

    все, что происходит с ссылкой происходит и с объектом.
___

## Вопрос 105

**Всегда ли передача по ссылке лучше передачи по значению?**
    
**Ответ:** 

Короткий ответ - да, в общем случае это так. Почему? Потому, что здесь производительность считается в количестве запусков конструктора копирование, т.к. он довольно требовательный. Из всех трех вариантов (передача по ссылке на константу, передача по значению, перемещение(_еще один метод передачи значения в функцию_)) самым выгодным в общем случае является метод передачи по ссылке на константу, который вызывает конструктор копирования не сильно больше, чем при перемещении, но который не так сильно раздувает код, по сравнению с перемещением(отдельные методы нужно будет написать), что улучшает читабельность, ускоряет отладу, упрощает поддержание кода, а это **ОЧЕНЬ-ОЧЕНЬ** важно.

Длинный(очень) ответ - не всегда, есть частные случаи, когда это не так, а передача по значению позволит ускорить программу. Читай эту [статью](http://scrutator.me/post/2018/07/30/value_vs_reference.aspx).

___

## Вопрос 106

**Всегда ли передача по ссылке лучше передачи по указателю?**
    
**Ответ:** 

Честно говоря, это практически однинаковые вещи, поскольку ссылка это все же разыменованный указатель(сейчас мы склоняемя к этой точке зрения), то реализция передачи значений по ссылке на константу основана на передаче по указателю.

Минусы:  
- усложнение синтаксиса
- дополнительные проверки `!= nullptr`, иначе программа обвалиться
- адрессная арифметика **ОЧЕНЬ-ОЧЕНЬ** не безопастна 
- разыменование медленнее, чем прямой доступ по значению
  
Плюсы:  
- те же, что и у передачи по ссылке на константу


Когда можно использовать передачу по указателю: **только** при работе с обычными массивами.

**Правило хорошего тона:** использовать передачу по ссылке, вместо передачи по адресу, когда это возможно.

___

## Вопрос 107

**Всегда ли можно обойтись без ссылки?**
    
**Ответ:** 

Начнем с передачи аргументов по константой ссылке (_т.е. оптимизированная передача по значению_).

Чтобы принять правильно решение относительно этой оптимизации надо учесть:
- Стоимость выделения памяти под копию объекта
- Стоимость конструктора копирования и деструктора
- Стоимость разыменования ссылки внутри функции
- Соглашение о вызове для конкретной функции — решение может быть разным при использовании регистров и стека
- Возможный выигрыш от оптимизаций, которые компилятор может применить зная что никакие аргументы функции не являются псевдонимами.

Поскольку каждый раз отвечать на эти вопросы очень трудоемко, то возложим это на компилятор, он будет принимать решения во время компиляции, вместо нас. Но такой подход тоже имеет свои недостатки, например, компилятор должен принять решение не учитывая факторы скрытые в реализации функции, а это может сыграть решающую роль.

Теперь что делать с конструктором копирования? Когда мы будем передавать объекты в функцию в качестве параметров, то будет вызываться конструктор копирования. Но если передавать к конструктор копирования объекты как пераметры, то будет вызываться тот же конструктор копировая => бесконечная рекурсия, это исправляется добовлением исключений в конструктор копирования, так чтобы в конструктор копирования объектры передавались по указателю.

Теперь что делать с возвратом `l-value` значений? Что-то с этим сделать можно.
```c++
a[i] = b;
*a.operator[](i) = b;
(++i) = x;
*i.operator++() = x;
(x = y) = z;
*x.operator=(y) = z;
*p = d;
*p.operator->() = d;
```
Но во всех остальных случаях это может противоречить здравому смыслу.

**Итог:** да, в C++ можно обойтись без ссылок, но цена потери довольно высока

# Вопрос 108

## Перегрузка функций 
Что же такое перегрузка? В Си может быть только одна функция с одним именем. Например, представим себе семейство функций, которые выводят на экран некоторое значение (число или строку). В Си мы могли бы описать их так:
``` c
void print_int (int v);
void print_float (float v);
void print_zts (const char *v);
… … …
int main () {
  print_int (10);
  print_float (5.5);
  print_zts ("Hello, world!\n");
}
```
Однако на самом деле, когда мы вызываем `print_нечто (10)`, компилятор уже знает, что 10 — это целое число. Но он никак не даёт нам воспользоваться этим знанием, и нам приходится вручную говорить, что печатаем мы именно int: `print_int (10)`.

Си++ как раз позволяет предоставить компилятору задачу по выбору нужного варианта функции. Для этого мы можем определить набор функций, каждая из которых имеет имя `print`, но которые принимают разные аргументы. Предыдущий пример тогда будет выглядеть следующим образом:
``` cpp
void print (int v);
void print (float v);
void print (const char *v);
… … …
int main () {
  print (10);
  print (5.5);
  print ("Hello, world!\n");
}
```
## Пробразование типов

Cи-стиль приведения типов данных доступен и языке C++, но считается не самодостаточным по сравнению с приведением типов в C++. Так как Си-стиль приведения типов не так точен, как C++-стиль приведения и не так заметен. Cи-стиль приведения типов данных может быть использован для преобразования любого типа в любой другой тип, при этом неважно насколько это небезопасное преобразование, например, преобразование целого числа в указатель типа `int`). Казалось бы, такое преобразование невозможно, однако компилятор с нами не согласен, но выполнит это приведение. И каков получится результат. ему совершенно не важно. Смотрим синтаксис приведения типов данных согласно Си-стилю:

``` c
(type) value
```
* где `type` — тип данных к которому преобразуется значение `val`

### static_cast — унарная операция приведения типов данных в С++
Операция `static_cast` доступна только в языке C++. `static_cast` может быть использована для преобразования одного типа в другой, но она не должна быть использована для выполнения недопустимого преобразования, например, преобразование значения в указатель или наоборот. Рекомендуется пользоваться операцией `static_cast`, нежели Cи-стилем приведения, потому что `static_cast` ограничивает недопустимое приведение типов и, следовательно — безопаснее.

Операция `static_cast`, грубо говоря, — это шаблон функции, в которой необходимо явно указать  тип данных для преобразования, то есть задать параметр шаблона.

``` cpp
static_cast<dataType>(value);
```

### dynamic_cast — унарная операция приведения типов данных в С++
Операция `dynamic_cast` доступна только в C++ и имеет смысл только, применительно к членам класса иерархии «полиморфных типов». Динамическое приведение типов данных может быть использовано для безопасного приведения указателя (или ссылки) на суперкласс, в указатель (или ссылку) на подкласс в иерархии классов. Если динамическое приведение типов — недопустимо, так как реальный тип объекта, указывает не на тот тип подкласса, приведение типов не выполнится.

Динамическое приведение указателя
При приведении указателя, в случае неудачи, `dynamic_cast` возвращает нулевой указатель NULL. Такое поведение обеспечивает быстрый способ определения, является ли данный объект частностью динамического типа.

``` cpp
type *subСlass = dynamic_cast<type *>(objPtr);
```

### const_cast — константное приведение типов данных
Операция `const_cast` доступна только в C++. Константное приведение используются, чтобы  константную переменную преобразовать в неконстантную. При этом, константным становится возвращаемое значение операции `const_cast`, а не сама переменная.

``` cpp
const_cast<dataType>(val);
```

### reinterpret_cast — операция приведения типов данных
Операция `reinterpret_cast` доступна только в C++ и является наименее безопасной формой приведения типов данных в С++, она позволяет интерпретировать значение в другой тип данных. `reinterpret_cast` не должна быть использована для приведения иерархии классов или преобразования константных переменных.

``` cpp
reinterpret_cast<dataType>(value);
```

## Доступ к полям
В C++ появились классы и объекты. Технически класс C++ - это тип структуры в C, а объект - переменная такого типа. Разница только в том, что в C++ есть еще модификаторы доступа и полями могут быть не только данные, но и функции (функции-методы).

Функция-метод - это обычная функция C, у которой первый параметр - это указатель на структуру, данные которой она обрабатывает: `this`. Если сравнить, как выглядят функции-методы в C++ и функции с параметром-указателем на структуру в C, то мы обнаружим, что всего лишь изменилась форма записи. В C++ получается короче, так как `this` и имя типа во многих случаях писать не обязательно (подразумевается по умолчанию).

Модификаторы доступа - это слова `public`, `private` и `protected`. В C вместо них была внимательность программиста: `public` - значит с этими полями делаю, что хочу; `private` - значит к этим полям обращаюсь только с помощью методов этой структуры; `protected` - то же, что `private`, но еще можно обращаться из методов унаследованных структур 